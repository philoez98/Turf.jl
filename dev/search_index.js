var documenterSearchIndex = {"docs":
[{"location":"#Turf.jl-1","page":"Turf.jl","title":"Turf.jl","text":"","category":"section"},{"location":"#","page":"Turf.jl","title":"Turf.jl","text":"A port of the Turf.js library to the Julia language.","category":"page"},{"location":"#Introduction-1","page":"Turf.jl","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Turf.jl","title":"Turf.jl","text":"Turf.jl is a port of the geospatial library Turf.js. It works with any type of spatial data that is compliant to  the GeoJSON specification.","category":"page"},{"location":"#","page":"Turf.jl","title":"Turf.jl","text":"Turf.jl implements most of the funcionalities available in the original library.","category":"page"},{"location":"#Installation-1","page":"Turf.jl","title":"Installation","text":"","category":"section"},{"location":"#","page":"Turf.jl","title":"Turf.jl","text":"Install Turf.jl within Julia using","category":"page"},{"location":"#","page":"Turf.jl","title":"Turf.jl","text":"import Pkg; Pkg.add(\"Turf\")","category":"page"},{"location":"#","page":"Turf.jl","title":"Turf.jl","text":"or from the REPL using Pkg mode","category":"page"},{"location":"#","page":"Turf.jl","title":"Turf.jl","text":"pkg> add Turf","category":"page"},{"location":"#Contents-1","page":"Turf.jl","title":"Contents","text":"","category":"section"},{"location":"#","page":"Turf.jl","title":"Turf.jl","text":"Pages=[\"getting-started.md\", \"examples.md\", \"methods.md\"]","category":"page"},{"location":"#Usage-1","page":"Turf.jl","title":"Usage","text":"","category":"section"},{"location":"#","page":"Turf.jl","title":"Turf.jl","text":"See the Getting Started section for an introduction to Turf.jl","category":"page"},{"location":"#","page":"Turf.jl","title":"Turf.jl","text":"Most of the time Turf.jl works very similar to the original library, so the Turf.js documentation is a good place to start.","category":"page"},{"location":"#","page":"Turf.jl","title":"Turf.jl","text":"Some examples can be found in the Examples section.","category":"page"},{"location":"#","page":"Turf.jl","title":"Turf.jl","text":"See the Index for a complete list of documented functions.","category":"page"},{"location":"#Contribute-1","page":"Turf.jl","title":"Contribute","text":"","category":"section"},{"location":"#","page":"Turf.jl","title":"Turf.jl","text":"Contributions are very appreciated! If you want to suggest something, or simply found a bug, please open a issue on Github. Thank you!","category":"page"},{"location":"#Index-1","page":"Turf.jl","title":"Index","text":"","category":"section"},{"location":"#","page":"Turf.jl","title":"Turf.jl","text":"","category":"page"},{"location":"getting-started/#Getting-Started-1","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"This is a very short and simple example to get you started with Turf. It shows a little script that extracts some informations from a FeatureCollection and updates its content.","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"Suppose we have a bunch of points scattered around on a map. We want to know where the center and the centroid of all those points are. In this case we'll use a .geojson file prepared with some random data. You can find all the files needed for this example inside the examples folder.","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"So let's start by importing Turf. Note that Turf also exports the GeoJSON.jl and the GeoInterface.jl packages, so we don't need to import them:","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"using Turf","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"To read a .geojson file into a String we use the function parsefile() from the GeoJSON.jl package:","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"fc = GeoJSON.parsefile(joinpath(dirname(pathof(Turf)), \"..\", \"docs\") * \"/examples/getting-started/example.geojson\")","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"So now we have a FeatureCollection object created from our file. We start to work on it by calculating both the center and the centroid of its features:","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"centroid_point = centroid(fc)\ncenter_point = center(fc)","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"Both functions return a Point. Let's push those points in the original FeatureCollection so that we can later visualize them. We also add the color-marker property to highlight them once plotted:","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"push!(fc.features, Feature(centroid_point, Dict(\"marker-color\" => \"#fff000\"))) # yellow\npush!(fc.features, Feature(center_point, Dict(\"marker-color\" => \"#eaa000\"))) # orange","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"Now let's convert our FeatureCollection back to a String using the geojson() function:","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"result = GeoJSON.geojson(fc)","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"As a last step, we write the modified FeatureCollection into a new file, called example.result.geojson:","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"open(joinpath(dirname(pathof(Turf)), \"..\", \"docs\") * \"/examples/getting-started/example.result.geojson\", \"w\") do file\n    write(file, result)\nend","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"And we're done! If we then plot the result here's how it looks like:","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"(Image: result)","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"You can open the example.result.geojson file in geojson.io and see the same result as above.","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"Here's the entire script:","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"using Turf\n\nfc = GeoJSON.parsefile(joinpath(dirname(pathof(Turf)), \"..\", \"docs\") * \"/examples/getting-started/example.geojson\")\n\ncentroid_point = centroid(fc)\ncenter_point = center(fc)\n\npush!(fc.features, Feature(centroid_point, Dict(\"marker-color\" => \"#fff000\")))\npush!(fc.features, Feature(center_point, Dict(\"marker-color\" => \"#eaa000\")))\n\nresult = GeoJSON.geojson(fc)\n\nopen(joinpath(dirname(pathof(Turf)), \"..\", \"docs\") * \"/examples/getting-started/example.result.geojson\", \"w\") do file\n    write(file, result)\nend","category":"page"},{"location":"getting-started/#Further-Reading-1","page":"Getting Started","title":"Further Reading","text":"","category":"section"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"For more examples and tutorials take a look at the Examples section.   For a complete overview of all the methods available in Turf, take a look at the Methods section.","category":"page"},{"location":"examples/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Points inside a Polygon: find which points are within a specific polygon on the map.\nSimplify a Geometry: simplify a shape to any degree.\nNearest Point: find the nearest point to a certain location.\nDifferent Grids: show different types of gridded data on a map.","category":"page"},{"location":"points-inside-polygon/#Points-inside-a-Polygon-1","page":"Points inside a Polygon","title":"Points inside a Polygon","text":"","category":"section"},{"location":"points-inside-polygon/#","page":"Points inside a Polygon","title":"Points inside a Polygon","text":"Example that shows how to find all points that are inside a specific shape (polygon) on the map.","category":"page"},{"location":"points-inside-polygon/#","page":"Points inside a Polygon","title":"Points inside a Polygon","text":"\nusing Turf\n\ngeo_data = GeoJSON.parsefile(joinpath(dirname(pathof(Turf)), \"..\", \"docs\") * \"/examples/points-inside-polygon/points-inside-polygon.geojson\")\n\npolygon = geo_data.features[1].geometry\n\nfor i in 2:length(geo_data.features)\n    feature = geo_data.features[i]\n    point = feature.geometry\n\n    if within(point, polygon)\n        feature.properties = Dict(\"marker-color\" => \"#ff0000\")\n    end\nend\n\nresult = geojson(geo_data)\n\nopen(joinpath(dirname(pathof(Turf)), \"..\", \"docs\") * \"/examples/points-inside-polygon/points-inside-polygon.result.geojson\", \"w\") do file\n    write(file, result)\nend\n","category":"page"},{"location":"points-inside-polygon/#","page":"Points inside a Polygon","title":"Points inside a Polygon","text":"(Image: inside)","category":"page"},{"location":"simplify/#Simplify-a-Geometry-1","page":"Simplify a Geometry","title":"Simplify a Geometry","text":"","category":"section"},{"location":"simplify/#","page":"Simplify a Geometry","title":"Simplify a Geometry","text":"This example shows how to simplify any geometry. Adjust the tolerance parameter to tune how much simpler the shape should be.","category":"page"},{"location":"simplify/#","page":"Simplify a Geometry","title":"Simplify a Geometry","text":"\nusing Turf\n\nshape = GeoJSON.parsefile(joinpath(dirname(pathof(Turf)), \"..\", \"docs\") * \"/examples/simplify/geometry.geojson\")\n\nsimplify!(shape, 0.4)\n\nresult = GeoJSON.geojson(shape)\n\nopen(joinpath(dirname(pathof(Turf)), \"..\", \"docs\") * \"/examples/simplify/geometry.result.geojson\", \"w\") do file\n    write(file, result)\nend\n","category":"page"},{"location":"simplify/#","page":"Simplify a Geometry","title":"Simplify a Geometry","text":"original:","category":"page"},{"location":"simplify/#","page":"Simplify a Geometry","title":"Simplify a Geometry","text":"(Image: not_sim)","category":"page"},{"location":"simplify/#","page":"Simplify a Geometry","title":"Simplify a Geometry","text":"simplified:","category":"page"},{"location":"simplify/#","page":"Simplify a Geometry","title":"Simplify a Geometry","text":"(Image: sim)","category":"page"},{"location":"nearest-point/#Nearest-Point-1","page":"Nearest Point","title":"Nearest Point","text":"","category":"section"},{"location":"nearest-point/#","page":"Nearest Point","title":"Nearest Point","text":"This example shows how to find the nearest point to a specific location on the map. The destination is shown in red.","category":"page"},{"location":"nearest-point/#","page":"Nearest Point","title":"Nearest Point","text":"using Turf\n\nfc = GeoJSON.parsefile(joinpath(dirname(pathof(Turf)), \"..\", \"docs\") * \"/examples/nearest-point/points.geojson\")\n\nfunction get_point_with_property(features, prop)\n    point = nothing\n    for (i, feature) in enumerate(features)\n        if haskey(feature.properties, prop)\n            point = features[i]\n            deleteat!(features, i)\n        end\n    end\n    return point\nend\n\ndestination = get_point_with_property(fc.features, \"tag\")\n\nnearest = nearestpoint(destination.geometry, [x.geometry for x in fc.features])\n\nindex = findfirst(x -> x.geometry.coordinates == nearest.coordinates, fc.features)\n\nfc.features[index].properties = Dict(\"marker-color\" => \"#fbb000\", \"tag\" => \"nearest-point\") # yellow marker\npush!(fc.features, destination)\n\nresult = geojson(fc)\n\nopen(joinpath(dirname(pathof(Turf)), \"..\", \"docs\") * \"/examples/nearest-point/points.result.geojson\", \"w\") do file\n    write(file, result)\nend\n","category":"page"},{"location":"nearest-point/#","page":"Nearest Point","title":"Nearest Point","text":"(Image: near)","category":"page"},{"location":"grids/#Different-Grids-1","page":"Different Grids","title":"Different Grids","text":"","category":"section"},{"location":"grids/#","page":"Different Grids","title":"Different Grids","text":"This example showcases different types of grids on a map, delimited by a bbox (bounding box).","category":"page"},{"location":"grids/#","page":"Different Grids","title":"Different Grids","text":"using Turf\n\nbox = [-95, 30 ,-85, 40]\ncellside = 60\n\npg = point_grid(box, cellside) # a grid of points\nrg = rectangle_grid(box, cellside, cellside / 2) # a grid of rectangles\ntg = triangle_grid(box, cellside) # a grid of triangles\nsg = square_grid(box, cellside) # a grid of squares\n\nfc = [pg, rg, tg, sg]\n\nfor (i, fcoll) in enumerate(fc)\n    open(joinpath(dirname(pathof(Turf)), \"..\", \"docs\") * \"/examples/grids/grid$(i).result.geojson\", \"w\") do file\n        write(file, geojson(fcoll))\n    end\nend\n","category":"page"},{"location":"grids/#","page":"Different Grids","title":"Different Grids","text":"(Image: points)     ","category":"page"},{"location":"grids/#","page":"Different Grids","title":"Different Grids","text":"(Image: rect)","category":"page"},{"location":"grids/#","page":"Different Grids","title":"Different Grids","text":"(Image: square)     ","category":"page"},{"location":"grids/#","page":"Different Grids","title":"Different Grids","text":"(Image: tri)","category":"page"},{"location":"methods/#Methods-1","page":"Methods","title":"Methods","text":"","category":"section"},{"location":"methods/#Contents-1","page":"Methods","title":"Contents","text":"","category":"section"},{"location":"methods/#","page":"Methods","title":"Methods","text":"Booleans\nConversion\nGrids\nMeasurement\nMisc\nTransformation","category":"page"},{"location":"methods/#Booleans-1","page":"Methods","title":"Booleans","text":"","category":"section"},{"location":"methods/#","page":"Methods","title":"Methods","text":"Modules = [Turf]\nPages   = [\"lib/Booleans.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"methods/#Turf.clockwise-Tuple{Union{Array{Array{Float64,1},1}, LineString}}","page":"Methods","title":"Turf.clockwise","text":"clockwise(line::Union{LineString, Vector{Position}})::Bool\n\nTake a ring and return true or false whether or not the ring is clockwise or counter-clockwise.\n\nExamples\n\njulia> line = LineString([[0, 0], [1, 1], [1, 0], [0, 0]])\nLineString(Array{Float64,1}[[0.0, 0.0], [1.0, 1.0], [1.0, 0.0], [0.0, 0.0]])\n\njulia> clockwise(line)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.concave-Tuple{Polygon}","page":"Methods","title":"Turf.concave","text":"concave(poly::Polygon)::Bool\n\nTake a polygon and return true or false as to whether it is concave or not.\n\nExamples\n\njulia> poly = Polygon([[[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]]])\nPolygon(Array{Array{Float64,1},1}[[[0.0, 0.0], [0.0, 1.0], [1.0, 1.0], [1.0, 0.0], [0.0, 0.0]]])\n\njulia> concave(poly)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.contains-Tuple{AbstractGeometry,AbstractGeometry}","page":"Methods","title":"Turf.contains","text":"contains(ft1::AbstractGeometry, ft2::AbstractGeometry)::Bool\n\nReturn true if the second geometry is completely contained by the first geometry. The interiors of both geometries must intersect and, the interior and boundary of the secondary (geometry b) must not intersect the exterior of the primary (geometry a). contains returns the exact opposite result of within.\n\nExamples\n\njulia> line = LineString([[1, 1], [1, 2], [1, 3], [1, 4]])\nLineString(Array{Float64,1}[[1.0, 1.0], [1.0, 2.0], [1.0, 3.0], [1.0, 4.0]])\n\njulia> point = Point([1, 2])\nPoint([1.0, 2.0])\n\njulia> contains(line, point)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.crosses-Tuple{AbstractGeometry,AbstractGeometry}","page":"Methods","title":"Turf.crosses","text":" crosses(ft1::AbstractGeometry, ft2::AbstractGeometry)::Bool\n\nReturn true if the intersection results in a geometry whose dimension is one less than the maximum dimension of the two source geometries and the intersection set is interior to both source geometries.\n\nExamples\n\njulia> line = LineString([[1, 1], [1, 2], [1, 3], [1, 4]])\nLineString(Array{Float64,1}[[1.0, 1.0], [1.0, 2.0], [1.0, 3.0], [1.0, 4.0]])\n\njulia> line2 = LineString([[-2, 2], [4, 2]])\nLineString(Array{Float64,1}[[-2.0, 2.0], [4.0, 2.0]])\n\njulia> crosses(line2, line)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.disjoint-Tuple{AbstractGeometry,AbstractGeometry}","page":"Methods","title":"Turf.disjoint","text":"disjoint(geom1::AbstractGeometry, geom2::AbstractGeometry)::Bool\n\nReturn true if the intersection of the two geometries is an empty set.\n\nExamples\n\njulia> poly = Polygon([[[-1, 2], [3, 2], [3, 3], [-1, 3], [-1, 2]]])\nPolygon(Array{Array{Float64,1},1}[[[-1.0, 2.0], [3.0, 2.0], [3.0, 3.0], [-1.0, 3.0], [-1.0, 2.0]]])\n\njulia> point = Point([1, 1])\nPoint([1.0, 1.0])\n\njulia> disjoint(poly, point)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.line_intersects-Tuple{AbstractLineString,AbstractLineString}","page":"Methods","title":"Turf.line_intersects","text":"line_intersects(line1::AbstractLineString, line2::AbstractLineString)\n\nFind a point that intersects LineStrings with two coordinates each.\n\nExamples\n\njulia> line1 = LineString([[124.584961,-12.768946],[126.738281,-17.224758]])\nLineString(Array{Float64,1}[[124.585, -12.7689], [126.738, -17.2248]])\n\njulia> line2 = LineString([[123.354492,-15.961329],[127.22168,-14.008696]])\nLineString(Array{Float64,1}[[123.354, -15.9613], [127.222, -14.0087]])\n\njulia> line_intersects(line1, line2)\nPoint([125.584, -14.8357])\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.overlap-Tuple{AbstractFeature,AbstractFeature}","page":"Methods","title":"Turf.overlap","text":"overlap(feat1::AbstractFeature, feat2::AbstractFeature)::Bool\n\nCompare two Features of the same dimension and return true if their intersection set results in a geometry different from both but of the same dimension. It applies to Polygon/Polygon, LineString/LineString, Multipoint/Multipoint, MultiLineString/MultiLineString and MultiPolygon/MultiPolygon.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.overlap-Tuple{AbstractGeometry,AbstractGeometry}","page":"Methods","title":"Turf.overlap","text":"overlap(geom1::AbstractGeometry, geom2::AbstractGeometry)::Bool\n\nCompare two Geometries of the same dimension and return true if their intersection set results in a geometry different from both but of the same dimension. It applies to Polygon/Polygon, LineString/LineString, Multipoint/Multipoint, MultiLineString/MultiLineString and MultiPolygon/MultiPolygon.\n\nExamples\n\njulia> poly1 = Polygon([[[0,0],[0,5],[5,5],[5,0],[0,0]]])\nPolygon(Array{Array{Float64,1},1}[[[0.0, 0.0], [0.0, 5.0], [5.0, 5.0], [5.0, 0.0], [0.0, 0.0]]])\n\njulia> poly2 = Polygon([[[1,1],[1,6],[6,6],[6,1],[1,1]]])\nPolygon(Array{Array{Float64,1},1}[[[1.0, 1.0], [1.0, 6.0], [6.0, 6.0], [6.0, 1.0], [1.0, 1.0]]])\n\njulia> overlap(poly1, poly2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.parallel-Tuple{LineString,LineString}","page":"Methods","title":"Turf.parallel","text":"parallel(line1::LineString, line2::LineString)::Bool\n\nReturn true if each segment of line1 is parallel to the correspondent segment of line2\n\nExamples\n\njulia> line1 = LineString([[9.170356, 45.477985], [9.164434, 45.482551], [9.166644, 45.484003]])\nLineString(Array{Float64,1}[[9.17036, 45.478], [9.16443, 45.4826], [9.16664, 45.484]])\n\njulia> line2 = LineString([[9.169356, 45.477985], [9.163434, 45.482551], [9.165644, 45.484003]])\nLineString(Array{Float64,1}[[9.16936, 45.478], [9.16343, 45.4826], [9.16564, 45.484]])\n\njulia> parallel(line1, line2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.point_in_polygon","page":"Methods","title":"Turf.point_in_polygon","text":"point_in_polygon(point::Point, polygon::Union{Polygon, MultiPolygon}, ignoreBoundary::Bool=false)::Bool\n\nTake a Point and a Polygon and determine if the point resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n\nExamples\n\njulia> point = Point([-77, 44])\nPoint([-77.0, 44.0])\n\njulia> poly = Polygon([[ [-81, 41], [-81, 47], [-72, 47], [-72, 41], [-81, 41]]])\nPolygon(Array{Array{Float64,1},1}[[[-81.0, 41.0], [-81.0, 47.0], [-72.0, 47.0], [-72.0, 41.0], [-81.0, 41.0]]])\n\njulia> point_in_polygon(point, poly)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.point_on_line","page":"Methods","title":"Turf.point_on_line","text":"point_on_line(point::Point, line::LineString, ignoreEndVertices::Bool=false)::Bool\n\nReturn true if a point is on a line. Accept a optional parameter to ignore the start and end vertices of the linestring.\n\nExamples\n\njulia> point = Point([1,1])\nPoint([1.0, 1.0])\n\njulia> line = LineString([[0, 0], [3, 3], [4, 4]])\nLineString(Array{Float64,1}[[0.0, 0.0], [3.0, 3.0], [4.0, 4.0]])\n\njulia> point_on_line(point, line)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.within-Tuple{AbstractGeometry,AbstractGeometry}","page":"Methods","title":"Turf.within","text":"within(ft1::AbstractGeometry, ft2::AbstractGeometry)::Bool\n\nReturn true if the first geometry is completely within the second geometry. The interiors of both geometries must intersect and, the interior and boundary of the primary (geometry a) must not intersect the exterior of the secondary (geometry b). within returns the exact opposite result of contains.\n\nExamples\n\njulia> line = LineString([[1, 1], [1, 2], [1, 3], [1, 4]])\nLineString(Array{Float64,1}[[1.0, 1.0], [1.0, 2.0], [1.0, 3.0], [1.0, 4.0]])\n\njulia> point = Point([1, 2])\nPoint([1.0, 2.0])\n\njulia> within(point, line)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"methods/#Conversion-1","page":"Methods","title":"Conversion","text":"","category":"section"},{"location":"methods/#","page":"Methods","title":"Methods","text":"Modules = [Turf]\nPages   = [\"Utils.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"methods/#Turf.area-Union{Tuple{T}, Tuple{T}} where T<:Union{AbstractFeatureCollection, AbstractGeometry}","page":"Methods","title":"Turf.area","text":"area(geojson::T) where {T <: Union{AbstractFeatureCollection, AbstractGeometry}}\n\nTake one or more features and return their area in square meters.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.clean","page":"Methods","title":"Turf.clean","text":"clean(geojson::AbstractGeometry, mutate::Bool=false)\n\nRemove redundant coordinates from any GeoJSON Geometry.\n\nExamples\n\njulia> line = LineString([[0, 0], [0, 2], [0, 5], [0, 8], [0, 10], [0, 10]])\nLineString(Array{Float64,1}[[0.0, 0.0], [0.0, 2.0], [0.0, 5.0], [0.0, 8.0], [0.0, 10.0], [0.0, 10.0]])\n\njulia> clean(line)\nLineString(Array{Float64,1}[[0.0, 0.0], [0.0, 10.0]])\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.clean","page":"Methods","title":"Turf.clean","text":"clean(geojson::AbstractFeature, mutate::Bool=false)\n\nRemove redundant coordinates from any GeoJSON Feature.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.clean!-Tuple{AbstractFeature}","page":"Methods","title":"Turf.clean!","text":"clean!(geojson::AbstractFeature)\n\nRemove redundant coordinates from any GeoJSON Feature. It modifies the GeoJSON geometry in place.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.clean!-Tuple{AbstractGeometry}","page":"Methods","title":"Turf.clean!","text":"clean!(geojson::AbstractGeometry)\n\nRemove redundant coordinates from any GeoJSON Geometry. It modifies the GeoJSON geometry in place.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.convert_area","page":"Methods","title":"Turf.convert_area","text":"convert_area(area::Real, originalUnit::String=\"meters\", finalUnit::String=\"kilometers\")::Real\n\nConvert an area to the requested unit.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.convert_length","page":"Methods","title":"Turf.convert_length","text":"convert_length(length::Real, originalUnit::String=\"kilometers\", finalUnit::String=\"kilometers\")::Real\n\nConvert a length to the requested unit.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.length_to_degrees","page":"Methods","title":"Turf.length_to_degrees","text":"length_to_degrees(distance::Real, units::String=\"kilometers\")::Real\n\nConvert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees. Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.length_to_radians","page":"Methods","title":"Turf.length_to_radians","text":"length_to_radians(distance::Real, units::String=\"kilometers\")::Real\n\nConvert a distance measurement (assuming a spherical Earth) from a real-world unit to radians. Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.radians_to_length","page":"Methods","title":"Turf.radians_to_length","text":"radians_to_length(radians::Real, units::String=\"kilometers\")::Real\n\nConvert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit. Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.to_WGS84-Tuple{Point}","page":"Methods","title":"Turf.to_WGS84","text":"to_WGS84(pos::Point)\n\nConvert 900913 x/y values to lon/lat.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.to_mercator-Tuple{Point}","page":"Methods","title":"Turf.to_mercator","text":"to_mercator(pos::Point)\n\nConvert lon/lat values to 900913 x/y.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Grids-1","page":"Methods","title":"Grids","text":"","category":"section"},{"location":"methods/#","page":"Methods","title":"Methods","text":"Modules = [Turf]\nPages   = [\"lib/Grids.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"methods/#Turf.hexgrid-Union{Tuple{T}, Tuple{Array{T,1},Real}, Tuple{Array{T,1},Real,Union{Nothing, Polygon}}, Tuple{Array{T,1},Real,Union{Nothing, Polygon},Bool}, Tuple{Array{T,1},Real,Union{Nothing, Polygon},Bool,String}} where T<:Real","page":"Methods","title":"Turf.hexgrid","text":" hexgrid(bbox::Vector{T}, cellSide::Real, mask::Union{Polygon, Nothing}=nothing, triangles::Bool=false, units::String=\"kilometers\") where {T <: Real}\n\nTake a bounding box and the diameter of the cell and return a FeatureCollection of flat-topped hexagons or triangles Polygon aligned in an \"odd-q\" vertical grid as described in Hexagonal Grids.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.point_grid-Union{Tuple{T}, Tuple{Array{T,1},Real}, Tuple{Array{T,1},Real,Union{Nothing, Polygon}}, Tuple{Array{T,1},Real,Union{Nothing, Polygon},String}} where T<:Real","page":"Methods","title":"Turf.point_grid","text":"point_grid(bbox::Vector{T}, cellSide::Real, mask::Union{Polygon, Nothing}=nothing, units::String=\"kilometers\") where {T <: Real}\n\nCreate a Point grid from a bounding box\n\nExamples\n\njulia> bbox = [-1, 2, 1, 3]\n4-element Array{Int64,1}:\n -1\n  2\n  1\n  3\n\njulia> point_grid(bbox, 100)\nFeatureCollection{Feature}(Feature[Feature(Point([-0.899869, 2.05034]), Dict{String,Any}()), Feature(Point([-0.899869, 2.94966]), Dict{String,Any}()), Feature(Point([0.0, 2.05034]), Dict{String,Any}()), Feature(Point([0.0, 2.94966]), Dict{String,Any}()), Feature(Point([0.899869, 2.05034]), Dict{String,Any}()), Feature(Point([0.899869, 2.94966]), Dict{String,Any}())], nothing, nothing)\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.rectangle_grid-Union{Tuple{T}, Tuple{Array{T,1},Real,Real}, Tuple{Array{T,1},Real,Real,Union{Nothing, Polygon}}, Tuple{Array{T,1},Real,Real,Union{Nothing, Polygon},String}} where T<:Real","page":"Methods","title":"Turf.rectangle_grid","text":"rectangle_grid(bbox::Vector{T}, width::Real, height::Real, mask::Union{Polygon, Nothing}=nothing, units::String=\"kilometers\") where {T <: Real}\n\nCreate a grid of rectangles from a bounding box.\n\nExamples\n\njulia> bbox = [-1, 2, 1, 3]\n4-element Array{Int64,1}:\n -1\n  2\n  1\n  3\n\njulia> rectangle_grid(bbox, 150, 100)\nFeatureCollection{Feature}(Feature[Feature(Polygon(Array{Array{Float64,1},1}[[[-0.674901, 2.05034], [-0.674901, 2.94966], [0.674901, 2.94966], [0.674901, 2.05034], [-0.674901, 2.05034]]]), Dict{String,Any}())], nothing, nothing)\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.square_grid-Union{Tuple{T}, Tuple{Array{T,1},Real}, Tuple{Array{T,1},Real,Union{Nothing, Polygon}}, Tuple{Array{T,1},Real,Union{Nothing, Polygon},String}} where T<:Real","page":"Methods","title":"Turf.square_grid","text":"square_grid(bbox::Vector{T}, cell_side::Real, mask::Union{Polygon, Nothing}=nothing, units::String=\"kilometers\") where {T <: Real}\n\nCreate a square grid from a bounding box.\n\nExamples\n\njulia> bbox = [-1, 2, 1, 3]\n4-element Array{Int64,1}:\n -1\n  2\n  1\n  3\n\njulia> square_grid(bbox, 100)\nFeatureCollection{Feature}(Feature[Feature(Polygon(Array{Array{Float64,1},1}[[[-0.899869, 2.05034], [-0.899869, 2.94966], [0.0, 2.94966], [0.0, 2.05034], [-0.899869, 2.05034]]]), Dict{String,Any}()), Feature(Polygon(Array{Array{Float64,1},1}[[[0.0, 2.05034], [0.0, 2.94966], [0.899869, 2.94966], [0.899869, 2.05034], [0.0, 2.05034]]]), Dict{String,Any}())], nothing, nothing)\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.triangle_grid-Union{Tuple{T}, Tuple{Array{T,1},Real}, Tuple{Array{T,1},Real,Union{Nothing, Polygon}}, Tuple{Array{T,1},Real,Union{Nothing, Polygon},String}} where T<:Real","page":"Methods","title":"Turf.triangle_grid","text":"triangle_grid(bbox::Vector{T}, cell_side::Real, mask::Union{Polygon, Nothing}=nothing, units::String=\"kilometers\") where {T <: Real}\n\nTake a bounding box and a cell depth and returns a set of triangular Polygons in a grid.\n\nExamples\n\njulia> bbox = [-1, 2, 1, 3]\n4-element Array{Int64,1}:\n -1\n  2\n  1\n  3\n\njulia> triangle_grid(bbox, 200)\nFeatureCollection{Feature}(Feature[Feature(Polygon(Array{Array{Float64,1},1}[[[-1.0, 2.0], [-1.0, 3.79864], [0.799737, 2.0], [-1.0, 2.0]]]), Dict{String,Any}()), Feature(Polygon(Array{Array{Float64,1},1}[[[-1.0, 3.79864], [0.799737, 3.79864], [0.799737, 2.0], [-1.0, 3.79864]]]), Dict{String,Any}()), Feature(Polygon(Array{Array{Float64,1},1}[[[0.799737, 2.0], [0.799737, 3.79864], [2.59947, 3.79864], [0.799737, 2.0]]]), Dict{String,Any}()), Feature(Polygon(Array{Array{Float64,1},1}[[[0.799737, 2.0], [2.59947, 3.79864], [2.59947, 2.0], [0.799737, 2.0]]]), Dict{String,Any}())], nothing, nothing)\n\n\n\n\n\n","category":"method"},{"location":"methods/#Measurement-1","page":"Methods","title":"Measurement","text":"","category":"section"},{"location":"methods/#","page":"Methods","title":"Methods","text":"Modules = [Turf]\nPages   = [\"lib/Distance.jl\", \"lib/Bearing.jl\", \"lib/Angle.jl\", \"lib/Centering.jl\", \"lib/Destination.jl\", \"lib/Ellipse.jl\", \"lib/Circle.jl\", \"lib/Lines.jl\", \"lib/Square.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"methods/#Turf.distance","page":"Methods","title":"Turf.distance","text":"distance(from::Position, to::Position, units::String=\"kilometers\")\n\nCalculate the distance between two Points or Positions in degrees, radians, miles, or kilometers. The distance is calculated using the Haversine formula to account for global curvature.\n\nExamples\n\njulia> point1 = Point([35, 45])\nPoint([35.0, 45.0])\n\njulia> point2 = Point([38, 43])\nPoint([38.0, 43.0])\n\njulia> distance(point1, point2)\n327.1241022693492\n\njulia> distance(point1, point2, \"miles\")\n203.26549343667307\n\njulia> distance(point1, point2, \"degrees\")\n2.9384603841845878\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.distance_to_segment","page":"Methods","title":"Turf.distance_to_segment","text":"distance_to_segment(point::Point, first::Point, last::Point, units::String=\"degrees\", method::String=\"planar\")\n\nReturn the distance between a point P on a segment AB.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.distance_weight-Union{Tuple{}, Tuple{T}} where T<:AbstractFeatureCollection","page":"Methods","title":"Turf.distance_weight","text":"distance_weight(; geojson::T, treshold::Real=10000, p::Integer=2, binary::Bool=false, alpha::Real=-1., standardization::Bool=false) where {T <: AbstractFeatureCollection}\n\nCalculate the Minkowski p-norm distance between two Points.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.midpoint-Tuple{Point,Point}","page":"Methods","title":"Turf.midpoint","text":"midpoint(first::Point, second::Point)\n\nTake two Points and returns a point midway between them. The midpoint is calculated geodesically, meaning the curvature of the earth is taken into account.\n\nExamples\n\njulia> point = Point([35, 45])\nPoint([35.0, 45.0])\n\njulia> point1 = Point([33, 42])\nPoint([33.0, 42.0])\n\njulia> midpoint(point, point1)\nPoint([33.9751, 43.5044])\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.nearestpoint-Tuple{Point,Array{Point,1}}","page":"Methods","title":"Turf.nearestpoint","text":"nearestpoint(target::Point, points::Vector{Point})\n\nTake a reference Point and an array of Points and return the point from the array closest to the reference. This calculation is geodesic.\n\nExamples\n\njulia> point = Point([35, 45])\nPoint([35.0, 45.0])\n\njulia> point1 = Point([33, 42])\nPoint([33.0, 42.0])\n\njulia> point2 = Point([39, 41])\nPoint([39.0, 41.0])\n\njulia> point3 = Point([35, 39])\nPoint([35.0, 39.0])\n\njulia> nearestpoint(point, [point1, point2, point3])\nPoint([33.0, 42.0])\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.pnorm_distance","page":"Methods","title":"Turf.pnorm_distance","text":"pnorm_distance(point1::Point, point2::Point, p::Integer=2)::Real\n\nCalculate the Minkowski p-norm distance between two Points.\n\nExamples\n\njulia> point = Point([35, 45])\nPoint([35.0, 45.0])\n\njulia> point1 = Point([33, 42])\nPoint([33.0, 42.0])\n\njulia> pnorm_distance(point, point1)\n3.605551275463989\n\njulia> pnorm_distance(point, point1, 1)\n5.0\n\njulia> pnorm_distance(point, point1, 3)\n3.2710663101885897\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.point_to_line_distance","page":"Methods","title":"Turf.point_to_line_distance","text":"point_to_line_distance(point::Point, line::LineString, units::String=\"kilometers\", method::String=\"geodesic\")\n\nReturn the minimum distance between a Point and a LineString, being the distance from a line the minimum distance between the point and any segment of the LineString.\n\nExamples\n\njulia> point = Point([35, 45])\nPoint([35.0, 45.0])\n\njulia> line = LineString([[35, 42], [38, 42.5], [40, 43]])\nLineString(Array{Float64,1}[[35.0, 42.0], [38.0, 42.5], [40.0, 43.0]])\n\njulia> point_to_line_distance(point, line)\n326.92768049303146\n\njulia> point_to_line_distance(point, line, \"degrees\", \"planar\")\n2.936700172184462\n\njulia> point_to_line_distance(point, line, \"degrees\")\n2.9366959846668\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.rhumb_distance","page":"Methods","title":"Turf.rhumb_distance","text":"rhumb_distance(from::Position, to::Position, units::String=\"kilometers\")\n\nCalculate the distance along a rhumb line between two Points or Positions in degrees, radians, miles, or kilometers.\n\nExamples\n\njulia> point1 = Point([35, 45])\nPoint([35.0, 45.0])\n\njulia> point2 = Point([38, 43])\nPoint([38.0, 43.0])\n\njulia> rhumb_distance(point1, point2)\n327.1421400706353\n\njulia> rhumb_distance(point1, point2, \"miles\")\n203.2767016067636\n\njulia> rhumb_distance(point1, point2, \"degrees\")\n2.9386224124916716\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.bearing","page":"Methods","title":"Turf.bearing","text":"bearing(start::Position, stop::Position, final::Bool=false)\n\nTake two Points or Positions and finds the geographic bearing between them, i.e. the angle measured in degrees from the north line (0 degrees).\n\nExamples\n\njulia> start = Position([-75, 45])\n2-element Array{Float64,1}:\n -75.0\n  45.0\n\njulia> stop = Position([20, 60])\n2-element Array{Float64,1}:\n 20.0\n 60.0\n\njulia> bearing(start, stop)\n37.75495852601734\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.bearing_to_azimuth-Tuple{Real}","page":"Methods","title":"Turf.bearing_to_azimuth","text":"bearing_to_azimuth(bearing::Real)::Real\n\nConvert any bearing angle from the north line direction (positive clockwise) and return an angle between 0-360 degrees (positive clockwise), 0 being the north line.\n\nExamples\n\njulia> bearing_to_azimuth(40)\n40\n\njulia> bearing_to_azimuth(-105)\n255\n\njulia> bearing_to_azimuth(410)\n50\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.rhumb_bearing","page":"Methods","title":"Turf.rhumb_bearing","text":"rhumb_bearing(start::Position, stop::Position, final::Bool=false)\n\nTake two Positions and finds the bearing angle between them along a Rhumb line i.e. the angle measured in degrees start the north line (0 degrees).\n\nExamples\n\njulia> start = Position([-75, 45])\n2-element Array{Float64,1}:\n -75.0\n  45.0\n\njulia> stop = Position([20, 60])\n2-element Array{Float64,1}:\n 20.0\n 60.0\n\njulia> rhumb_bearing(start, stop)\n75.28061364784332\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.angle_adjacent","page":"Methods","title":"Turf.angle_adjacent","text":"angle_adjacent(start::Position, mid::Position, stop::Position, explementary::Bool=false, mercator::Bool=false)\n\nFind the angle formed by two adjacent segments defined by 3 points. The result will be the (positive clockwise) angle with origin on the start-mid segment, or its explementary angle if required.\n\nExamples\n\njulia> p1 = Point([-35, 55])\nPoint([-35.0, 55.0])\n\njulia> p2 = Point([-34.8, 57.5])\nPoint([-34.8, 57.5])\n\njulia> p3 = Point([-33.4, 59.1])\nPoint([-33.4, 59.1])\n\njulia> angle_adjacent(p1, p2, p3, false, false)\n202.8279033760424\n\njulia> angle_adjacent(p1, p2, p3, true, false) # explementary angle\n157.1720966239576\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.center-Union{Tuple{T}, Tuple{T}} where T<:Union{AbstractFeatureCollection, AbstractGeometry}","page":"Methods","title":"Turf.center","text":"center(geojson::T) where {T <: AbstractGeometry}\n\nTake a GeoJson Geometry and return the absolute center point.\n\nExamples\n\njulia> line = LineString([[1, 2], [4, 6], [8, 9.5], [12, 13.4]])\nLineString(Array{Float64,1}[[1.0, 2.0], [4.0, 6.0], [8.0, 9.5], [12.0, 13.4]])\n\njulia> center(line)\nPoint([6.5, 7.7])\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.centroid-Union{Tuple{T}, Tuple{T}} where T<:AbstractFeatureCollection","page":"Methods","title":"Turf.centroid","text":"centroid([geojson::T])::Point where {T <: AbstractFeatureCollection}\n\nTakes one or more features and calculates the centroid using the mean of all vertices. This lessens the effect of small islands and artifacts when calculating the centroid of a set of polygons.\n\nExamples\n\njulia> line = LineString([[1, 2], [4, 6], [8, 9.5], [12, 13.4]])\nLineString(Array{Float64,1}[[1.0, 2.0], [4.0, 6.0], [8.0, 9.5], [12.0, 13.4]])\n\njulia> centroid(line)\nPoint([6.25, 7.725])\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.centroid-Union{Tuple{T}, Tuple{T}} where T<:AbstractGeometry","page":"Methods","title":"Turf.centroid","text":"centroid([geojson::T])::Point where {T <: AbstractGeometry}\n\nTakes one or more features and calculates the centroid using the mean of all vertices. This lessens the effect of small islands and artifacts when calculating the centroid of a set of polygons.\n\nExamples\n\njulia> line = LineString([[1, 2], [4, 6], [8, 9.5], [12, 13.4]])\nLineString(Array{Float64,1}[[1.0, 2.0], [4.0, 6.0], [8.0, 9.5], [12.0, 13.4]])\n\njulia> centroid(line)\nPoint([6.25, 7.725])\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.masscenter-Union{Tuple{T}, Tuple{T}} where T<:AbstractGeometry","page":"Methods","title":"Turf.masscenter","text":"masscenter(geojson::T) where {T <: AbstractGeometry}\n\nTake any GeoJson Geometry and return its center of mass using this formula: Centroid of Polygon.\n\nExamples\n\njulia> line = LineString([[1, 2], [4, 6], [8, 9.5], [12, 13.4]])\nLineString(Array{Float64,1}[[1.0, 2.0], [4.0, 6.0], [8.0, 9.5], [12.0, 13.4]])\n\njulia> masscenter(line)\nPoint([6.25, 7.725])\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.meancenter-Union{Tuple{T}, Tuple{T}, Tuple{T,Real}} where T<:Union{AbstractFeatureCollection, AbstractGeometry}","page":"Methods","title":"Turf.meancenter","text":"meancenter(geojson::T, weight::Real=1.) where {T <: Union{AbstractGeometry, AbstractFeatureCollection}}\n\nTake a GeoJson Geometry and return the mean center. Can be weighted.\n\nExamples\n\njulia> line = LineString([[1, 2], [4, 6], [8, 9.5], [12, 13.4]])\nLineString(Array{Float64,1}[[1.0, 2.0], [4.0, 6.0], [8.0, 9.5], [12.0, 13.4]])\n\njulia> meancenter(line)\nPoint([6.25, 7.725])\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.mediancenter-Union{Tuple{T}, Tuple{T}, Tuple{T,Real}, Tuple{T,Real,Real}, Tuple{T,Real,Real,Integer}} where T<:AbstractFeatureCollection","page":"Methods","title":"Turf.mediancenter","text":"mediancenter(geojson::T, weight::Real=1., tol::Real=0.001, count::Integer=10) where {T <: AbstractFeatureCollection}\n\nTake a FeatureCollection of points and calculate the median center, algorithimically. The median center is understood as the point that is requires the least total travel from all other points.\n\nExamples\n\njulia> fc = FeatureCollection([Feature(Point([0, 0])),Feature(Point([9, 9])), Feature(Point([9.25, 9.25])),\n             Feature(Point([9.5, 9.5])), Feature(Point([9.75, 9.75])), Feature(Point([10, 10]))])\nFeatureCollection{Feature}(Feature[Feature(Point([0.0, 0.0]), Dict{String,Any}()), Feature(Point([9.0, 9.0]), Dict{String,Any}()), Feature(Point([9.25, 9.25]), Dict{String,Any}()), Feature(Point([9.5, 9.5]), Dict{String,Any}()), Feature(Point([9.75, 9.75]), Dict{String,Any}()), Feature(Point([10.0, 10.0]), Dict{String,Any}())], nothing, nothing)\n\njulia> mediancenter(fc)\nPoint([9.25425, 9.25425])\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.destination","page":"Methods","title":"Turf.destination","text":"destination(origin::Position, distance::Real, bearing::Real, units::String=\"kilometers\")\n\nTake a Point or a Position and calculate the location of a destination point given a distance in degrees, radians, miles, or kilometers; and bearing in degrees. The destination is calculated using the Haversine formula to account for global curvature.\n\nExamples\n\njulia> point = Point([-75, 38])\nPoint([-75.0, 38.0])\n\njulia> destination(point, 100, 0)\nPoint([-75.0, 38.8993])\n\njulia> destination(point, 100, 45)\nPoint([-74.1859, 38.6331])\n\njulia> destination(point, 50, 0, \"miles\")\nPoint([-75.0, 38.7237])\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.rhumb_destination","page":"Methods","title":"Turf.rhumb_destination","text":"rhumb_destination(origin::Position, distance::Real, bearing::Real, units::String=\"kilometers\")\n\nTake a Point or a Position and return the destination Point having travelled the given distance along a Rhumb line from the origin Point with the (varant) given bearing.\n\nExamples\n\njulia> point = Point([-75, 38])\nPoint([-75.0, 38.0])\n\njulia> rhumb_destination(point, 100, 0)\nPoint([-75.0, 38.8993])\n\njulia> rhumb_destination(point, 100, 45)\nPoint([-74.1895, 38.6359])\n\njulia> rhumb_destination(point, 50, 0, \"miles\")\nPoint([-75.0, 38.7237])\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.ellipse-Tuple{}","page":"Methods","title":"Turf.ellipse","text":"ellipse(; center::Point, xAxis::Real, yAxis::Real, steps::Integer=64, angle::Real=0., pivot::Union{Point, Nothing}=nothing, units::String=\"kilometers\")\n\nTake a Point and calculates the ellipse polygon given two semi-axes expressed in variable units and steps for precision.\n\nExamples\n\njulia> center = Point([10, 45])\nPoint([10.0, 45.0])\n\njulia> ellipse(center=center, xAxis=20, yAxis=7.5, steps=10)\nPolygon(Array{Array{Float64,1},1}[[[10.0872, 45.0634], [10.0218, 45.0672], [9.97817, 45.0672], [9.91279, 45.0634], [9.74563, 45.0], [9.91279, 44.9366], [9.97817, 44.9328], [10.0218, 44.9328], [10.0872, 44.9366], [10.2544, 45.0], [10.0872, 45.0634]]])\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.circle-Tuple{}","page":"Methods","title":"Turf.circle","text":"circle(; center::Union{Point, Position}, radius::Real=5., steps::Integer=64, units::String=\"kilometers\")\n\nTake a Point or a Position and calculate the circle polygon given a radius in degrees, radians, miles, or kilometers; and steps for precision.\n\nExamples\n\njulia> point = Point([35, 45])\nPoint([35.0, 45.0])\n\njulia> circle(center=point, steps=5)\nPolygon(Array{Array{Float64,1},1}[[[34.9395, 45.0139], [34.9626, 44.9636], [35.0374, 44.9636], [35.0605, 45.0139], [35.0, 45.045], [34.9395, 45.0139]]])\n\njulia> circle(center=point, radius=2.5, steps=5, units=\"degrees\")\nPolygon(Array{Array{Float64,1},1}[[[31.5893, 45.7231], [32.99, 42.9571], [37.01, 42.9571], [38.4107, 45.7231], [35.0, 47.5029], [31.5893, 45.7231]]])\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.sector","page":"Methods","title":"Turf.sector","text":"sector(center::Point, radius::Real, bearing1::Real, bearing2::Real, steps::Integer=64, units::String=\"kilometers\")\n\nCreates a circular sector of a circle of given radius and center Point, between (clockwise) bearing1 and bearing2; 0 bearing is North of center point, positive clockwise.\n\nExamples\n\njulia> point = Point([35, 45])\nPoint([35.0, 45.0])\n\njulia> sector(point, 5, 0, 0.5, 5)\nPolygon(Array{Array{Float64,1},1}[[[35.0, 45.0], [35.0, 45.045], [35.0006, 45.045], [35.0, 45.0]]])\n\njulia> sector(point, 5, 0, 270, 5)\nPolygon(Array{Array{Float64,1},1}[[[35.0, 45.0], [35.0, 45.045], [35.0605, 45.0139], [35.0374, 44.9636], [34.9626, 44.9636], [34.9364, 45.0], [35.0, 45.0]]])\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.linearc","page":"Methods","title":"Turf.linearc","text":"linearc(center::Point, radius::Real, bearing1::Real, bearing2::Real, steps::Real=64., units::String=\"kilometers\")\n\nCreate a circular arc, of a circle of the given radius and center point, between bearing1 and bearing2; 0 bearing is North of center point, positive clockwise.\n\nExamples\n\njulia> point = Point([35, 45])\nPoint([35.0, 45.0])\n\njulia> linearc(point, 5, 0, 10, 5)\nLineString(Array{Float64,1}[[35.0, 45.045], [35.0111, 45.0443]])\n\njulia> linearc(point, 5, 0, 270, 5)\nLineString(Array{Float64,1}[[35.0, 45.045], [35.0605, 45.0139], [35.0374, 44.9636], [34.9626, 44.9636], [34.9364, 45.0]])\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.linesegment-Tuple{LineString}","page":"Methods","title":"Turf.linesegment","text":"linesegment(geojson::LineString)\n\nCreate a 2-vertex LineString segments from a LineString.\n\nExamples\n\njulia> line = LineString([[0, 1], [2, 3], [3, 3]])\nLineString(Array{Float64,1}[[0.0, 1.0], [2.0, 3.0], [3.0, 3.0]])\n\njulia> linesegment(line)\n2-element Array{LineString,1}:\n LineString(Array{Float64,1}[[0.0, 1.0], [2.0, 3.0]])\n LineString(Array{Float64,1}[[2.0, 3.0], [3.0, 3.0]])\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.square-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:Real","page":"Methods","title":"Turf.square","text":"square(bbox::Vector{T}) where {T <: Real}\n\nTake a bounding box and calculates the minimum square bounding box that would contain the input.\n\nExamples\n\njulia> bbox = [-1, 1, 2, 3.5]\n4-element Array{Float64,1}:\n -1.0\n  1.0\n  2.0\n  3.5\n\njulia> square(bbox)\n4-element Array{Float64,1}:\n -1.0\n  0.75\n  2.0\n  3.75\n\n\n\n\n\n","category":"method"},{"location":"methods/#Misc-1","page":"Methods","title":"Misc","text":"","category":"section"},{"location":"methods/#","page":"Methods","title":"Methods","text":"Modules = [Turf]\nPages   = [\"lib/BBox.jl\", \"lib/BezierSpline.jl\", \"lib/Planes.jl\", ]\nOrder   = [:function, :type]","category":"page"},{"location":"methods/#Turf.bbox-Union{Tuple{T}, Tuple{T}} where T<:AbstractFeature","page":"Methods","title":"Turf.bbox","text":" bbox(geojson::T) where {T<: AbstractFeature}\n\nTake a Feature and return a bounding box around its geometry.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.bbox-Union{Tuple{T}, Tuple{T}} where T<:AbstractFeatureCollection","page":"Methods","title":"Turf.bbox","text":"bbox(geojson::T) where {T<:AbstractFeatureCollection}\n\nTake a set of features, calculate the bbox of all input features, and returns a bounding box.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.bbox-Union{Tuple{T}, Tuple{T}} where T<:AbstractGeometry","page":"Methods","title":"Turf.bbox","text":"bbox(geojson::T) where {T <: AbstractGeometry}\n\nTake a GeoJSON Geometry and calculate its bounding box.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.bbox_polygon-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:Real","page":"Methods","title":"Turf.bbox_polygon","text":"bbox_polygon(bbox::Vector{T}) where {T <: Real}\n\nTake a bbox and return an equivalent Polygon.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.bezier-Tuple{LineString}","page":"Methods","title":"Turf.bezier","text":"bezier(line::LineString; resolution::Real=10000, sharpness::Real=0.85)\n\nTake a LineString and returns a curved version by applying a Bezier spline algorithm.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.planepoint-Tuple{Point,Polygon}","page":"Methods","title":"Turf.planepoint","text":"planepoint(point::Point, triangle::Polygon)\n\nTake a triangular plane as a Polygon and a Point within that triangle and returns the z-value at that point.\n\nExamples\n\njulia> point = Point([-175, 22])\nPoint([-175.0, 22.0])\n\njulia> triangle = Polygon([[-174.55, 32.54, 55], [-186.94, 17.64, 24.5], [-167.95, 17.81, 33.6], [-174.55, 32.54, 55]])\nPolygon(Array{Array{Float64,1},1}[[[-174.55, 32.54, 55.0], [-186.94, 17.64, 24.5], [-167.95, 17.81, 33.6], [-174.55, 32.54, 55.0]]])\n\njulia> planepoint(point, triangle)\n37.28550123965308\n\n\n\n\n\n","category":"method"},{"location":"methods/#Transformation-1","page":"Methods","title":"Transformation","text":"","category":"section"},{"location":"methods/#","page":"Methods","title":"Methods","text":"Modules = [Turf]\nPages   = [\"lib/Transformations.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"methods/#Turf.combine-Tuple{FeatureCollection}","page":"Methods","title":"Turf.combine","text":"combine([ft::FeatureCollection])\n\nCombine a FeatureCollection of Point, LineString, or Polygon features into MultiPoint, MultiLineString, or MultiPolygon features.\n\nExamples\n\njulia> l1 = LineString([[102.0,-10.0],[130.0,4.0]])\nLineString(Array{Float64,1}[[102.0, -10.0], [130.0, 4.0]])\n\njulia> l2 = LineString([[40.0,-20.0],[150.0,18.0]])\nLineString(Array{Float64,1}[[40.0, -20.0], [150.0, 18.0]])\n\njulia> combine(FeatureCollection([Feature(l1), Feature(l2)]))\nFeatureCollection{Feature}(Feature[Feature(MultiLineString(Array{Array{Float64,1},1}[[[102.0, -10.0], [130.0, 4.0], [40.0, -20.0], [150.0, 18.0]]]), Dict{String,Any}())], nothing, nothing)\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.convert_to","page":"Methods","title":"Turf.convert_to","text":"convert_to([geojson::AbstractGeometry[, projection::String]], mutate::Bool=false)\n\nConvert a GeoJSON geojsonect to the defined projection.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.explode-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T<:Union{AbstractFeatureCollection, AbstractGeometry}","page":"Methods","title":"Turf.explode","text":"explode([geojson::T], pointsOnly::Bool=false)::FeatureCollection where {T <: Union{AbstractFeatureCollection, AbstractGeometry}}\n\nTakes a Geometry or a FeatureCollection and returns all positions as Points.\n\nExamples\n\njulia> poly = Polygon([[[100, 0], [101, 0], [101, 1], [100, 1], [100, 0]]])\nPolygon(Array{Array{Float64,1},1}[[[100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0]]])\n\njulia> explode(poly, true)\n5-element Array{Point,1}:\n Point([100.0, 0.0])\n Point([101.0, 0.0])\n Point([101.0, 1.0])\n Point([100.0, 1.0])\n Point([100.0, 0.0])\n\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.flip-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T<:Union{AbstractFeature, AbstractGeometry}","page":"Methods","title":"Turf.flip","text":"flip([geojson::T], mutate::Bool=false) where {T <: Union{AbstractFeature, AbstractGeometry}}\n\nTake input Features and Geometries and flips all of their coordinates from [x, y] to [y, x].\n\nExamples\n\njulia> point = Point([77.34374999999999,43.58039085560784,3000])\nPoint([77.3437, 43.5804, 3000.0])\n\njulia> flip(point)\nPoint([43.5804, 77.3437, 3000.0])\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.lineclip-Union{Tuple{P}, Tuple{T}, Tuple{Array{P,1},Array{T,1}}} where P<:AbstractPoint where T<:Real","page":"Methods","title":"Turf.lineclip","text":"Cohen-Sutherland line clippign algorithm, adapted to efficiently to handle polylines rather than just segments\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.polygon_tangents-Tuple{Point,Polygon}","page":"Methods","title":"Turf.polygon_tangents","text":"polygon_tangents(pt::Point, poly::Polygon)\n\nFinds the tangents of a Polygon from a Point.\n\nExamples\n\n```jldoctest julia> point = Point([92.46093749999999,54.67383096593114]) Point([92.4609, 54.6738])\n\njulia> poly = Polygon([[[100, 0], [101, 0], [101, 1], [100, 1], [100, 0]]]) Polygon(Array{Array{Float64,1},1}[[[100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0]]])\n\njulia> poly = Polygon([[[48.1641, 20.6328], [76.6406, 20.6328], [76.6406, 38.8226], [48.1641, 38.8226], [48.1641, 20.6328]]]) Polygon(Array{Array{Float64,1},1}[[[48.1641, 20.6328], [76.6406, 20.6328], [76.6406, 38.8226], [48.1641, 38.8226], [48.1641, 20.6328]]])\n\njulia> polygon_tangents(point, poly) FeatureCollection{Feature}(Feature[Feature(Point([48.1641, 38.8226]), Dict{String,Any}()), Feature(Point([76.6406, 20.6328]), Dict{String,Any}())], nothing, nothing)  ```\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.polygon_to_line-Tuple{Polygon}","page":"Methods","title":"Turf.polygon_to_line","text":"polygon_to_line([poly::Polygon])\n\nConverts a Polygon to LineString or MultiLineString\n\nExamples\n\njulia> poly = Polygon([[[-2.275543, 53.464547],[-2.275543, 53.489271],[-2.215118, 53.489271],[-2.215118, 53.464547],[-2.275543, 53.464547]]])\nPolygon(Array{Array{Float64,1},1}[[[-2.27554, 53.4645], [-2.27554, 53.4893], [-2.21512, 53.4893], [-2.21512, 53.4645], [-2.27554, 53.4645]]])\n\njulia> polygon_to_line(poly)\nLineString(Array{Float64,1}[[-2.27554, 53.4645], [-2.27554, 53.4893], [-2.21512, 53.4893], [-2.21512, 53.4645], [-2.27554, 53.4645]])\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.polygonclip-Union{Tuple{T}, Tuple{P}, Tuple{Array{P,1},Array{T,1}}} where T<:Real where P<:AbstractPoint","page":"Methods","title":"Turf.polygonclip","text":"Sutherland-Hodgeman polygon clipping algorithm.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.scale","page":"Methods","title":"Turf.scale","text":"scale([feature::Feature[, factor::Real]], origin::String=\"centroid\")\n\nScale a Feature.\n\nExamples\n\njulia> feature = Feature(Polygon([[[0, 29], [3.5, 29], [2.5, 32], [0, 29]]]))\nFeature(Polygon(Array{Array{Float64,1},1}[[[0.0, 29.0], [3.5, 29.0], [2.5, 32.0], [0.0, 29.0]]]), Dict{String,Any}())\n\njulia> scale(feature, 0.1)\nFeature(Polygon(Array{Array{Float64,1},1}[[[1.3495, 29.675], [1.70067, 29.675], [1.59896, 29.975], [1.3495, 29.675]]]), Dict{String,Any}())\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.simplify","page":"Methods","title":"Turf.simplify","text":"simplify(geojson::FeatureCollection, tolerance::Real=1., hq::Bool=false, mutate::Bool=false)\n\nTake a FeatureCollection and return a simplified version. Internally uses an adaptation of simplify-js to perform simplification using the Ramer-Douglas-Peucker algorithm.\n\nExamples\n\njulia> poly = Polygon([[\n    [-70.603637, -33.399918],\n    [-70.614624, -33.395332],\n    [-70.639343, -33.392466],\n    [-70.659942, -33.394759],\n    [-70.683975, -33.404504],\n    [-70.697021, -33.419406],\n    [-70.701141, -33.434306],\n    [-70.700454, -33.446339],\n    [-70.694274, -33.458369],\n    [-70.682601, -33.465816],\n    [-70.668869, -33.472117],\n    [-70.646209, -33.473835],\n    [-70.624923, -33.472117],\n    [-70.609817, -33.468107],\n    [-70.595397, -33.458369],\n    [-70.587158, -33.442901],\n    [-70.587158, -33.426283],\n    [-70.590591, -33.414248],\n    [-70.594711, -33.406224],\n    [-70.603637, -33.399918]]])\n\njulia> simplify(poly, 0.01)\nPolygon(Array{Array{Float64,1},1}[[[-70.6036, -33.3999], [-70.684, -33.4045], [-70.7011, -33.4343], [-70.6943, -33.4584], [-70.6689, -33.4721], [-70.6098, -33.4681], [-70.5872, -33.4429], [-70.6036, -33.3999]]])\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.simplify","page":"Methods","title":"Turf.simplify","text":"simplify(geojson::AbstractFeature, tolerance::Real=1., hq::Bool=false, mutate::Bool=false)\n\nTake a GeoJSON Feature and return a simplified version. Internally uses an adaptation of simplify-js to perform simplification using the Ramer-Douglas-Peucker algorithm.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.simplify","page":"Methods","title":"Turf.simplify","text":"simplify(geojson::AbstractGeometry, tolerance::Real=1., hq::Bool=false, mutate::Bool=false)\n\nTake a GeoJSON Geometry and return a simplified version. Internally uses an adaptation of simplify-js to perform simplification using the Ramer-Douglas-Peucker algorithm.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.simplify!","page":"Methods","title":"Turf.simplify!","text":"simplify(geojson::AbstractFeature, tolerance::Real=1., hq::Bool=false)\n\nTake a GeoJSON Feature and return a simplified version, modifying the original Feature. Internally uses an adaptation of simplify-js to perform simplification using the Ramer-Douglas-Peucker algorithm.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.simplify!","page":"Methods","title":"Turf.simplify!","text":"simplify(geojson::AbstractGeometry, tolerance::Real=1., hq::Bool=false)\n\nTake a GeoJSON Geometry and return a simplified version, modifying the original Geometry. Internally uses an adaptation of simplify-js to perform simplification using the Ramer-Douglas-Peucker algorithm.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.simplify!","page":"Methods","title":"Turf.simplify!","text":"simplify(geojson::FeatureCollection, tolerance::Real=1., hq::Bool=false)\n\nTake a FeatureCollection and return a simplified version, modifying the original FeatureCollection. Internally uses an adaptation of simplify-js to perform simplification using the Ramer-Douglas-Peucker algorithm.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Turf.tag-Tuple{FeatureCollection,FeatureCollection,String,String}","page":"Methods","title":"Turf.tag","text":"tag(fc1::FeatureCollection, fc2::FeatureCollection, in_field::String, out_field::String)::FeatureCollection\n\nTake a set of Points and a set of Polygons and performs a spatial join.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.transform_rotate-Union{Tuple{}, Tuple{T}} where T<:AbstractGeometry","page":"Methods","title":"Turf.transform_rotate","text":"transform_rotate([geojson::T[, angle::Real], pivot::Point=nothing, mutate::Bool=false) where {T <: AbstractGeometry}\n\nRotates any geojson Feature or Geometry of a specified angle, around its centroid or a given pivot point; all rotations follow the right-hand rule.\n\nExamples\n\njulia> point = Point([-75.69926351308823,45.43145021122502])\nPoint([-75.6993, 45.4315])\n\njulia> transform_rotate(geojson=point, angle=80., pivot=Point([-75.6, 45.3]))\nPoint([-75.433, 45.3915])\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.transform_scale-Union{Tuple{T}, Tuple{T,Real}, Tuple{T,Real,String}, Tuple{T,Real,String,Bool}} where T<:AbstractFeatureCollection","page":"Methods","title":"Turf.transform_scale","text":"transform_scale([geojson::T[, factor::Float64]], origin::String=\"centroid\") where {T <: AbstractFeatureCollection}\n\nScale a GeoJson from a given point by a factor of scaling (ex: factor=2 would make the GeoJson 200% larger). If a FeatureCollection is provided, the origin point will be calculated based on each individual Feature.\n\nExamples\n\njulia> coll = FeatureCollection([Feature(Point([-75.69926351308823,45.43145021122502])), Feature(Polygon([[[0, 29], [3.5, 29], [2.5, 32], [0, 29]]]))])\nFeatureCollection{Feature}(Feature[Feature(Point([-75.6993, 45.4315]), Dict{String,Any}()), Feature(Polygon(Array{Array{Float64,1},1}[[[0.0, 29.0], [3.5, 29.0], [2.5, 32.0], [0.0, 29.0]]]), Dict{String,Any}())], nothing, nothing)\n\njulia> transform_scale(coll, 0.1)\nFeatureCollection{Feature}(Feature[Feature(Point([-75.6993, 45.4315]), Dict{String,Any}()), Feature(Polygon(Array{Array{Float64,1},1}[[[1.3495, 29.675], [1.70067, 29.675], [1.59896, 29.975], [1.3495, 29.675]]]), Dict{String,Any}())], nothing, nothing)\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.transform_translate-Union{Tuple{R}, Tuple{T}, Tuple{T,R,R}, Tuple{T,R,R,R}, Tuple{T,R,R,R,Bool}, Tuple{T,R,R,R,Bool,String}} where R<:Real where T<:Union{AbstractFeature, AbstractGeometry}","page":"Methods","title":"Turf.transform_translate","text":"transform_translate([geojson::T[, distance::R[, direction::R]]], vertical::R=0, mutate::Bool=false, units::String=\"kilometers\") where {T <: Union{AbstractFeature, AbstractGeometry}, R <: Real}\n\nMoves any geojson Feature or Geometry of a specified distance along a Rhumb Line on the provided direction angle.\n\nExamples\n\njulia> poly = Polygon([[[0, 29], [3.5, 29], [2.5, 32], [0, 29]]])\nPolygon(Array{Array{Float64,1},1}[[[0.0, 29.0], [3.5, 29.0], [2.5, 32.0], [0.0, 29.0]]])\n\njulia> transform_translate(poly, 300, 70)\nPolygon(Array{Array{Float64,1},1}[[[2.91184, 29.9228], [6.41184, 29.9228], [5.50479, 32.9228], [2.91184, 29.9228]]])\n\n\n\n\n\n","category":"method"},{"location":"methods/#Turf.intersection-Union{Tuple{T}, Tuple{Point,Point,Any,Array{T,1}}} where T<:Real","page":"Methods","title":"Turf.intersection","text":"Intersect a segment against one of the 4 lines that make up the bbox\n\n\n\n\n\n","category":"method"}]
}
