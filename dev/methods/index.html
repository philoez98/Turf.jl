<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods · Turf.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Turf.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><span class="toctext">Home</span><ul><li><a class="toctext" href="../">Turf.jl</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../getting-started/">Getting Started</a></li><li><a class="toctext" href="../examples/">Examples</a></li><li class="current"><a class="toctext" href>Methods</a><ul class="internal"><li><a class="toctext" href="#Contents-1">Contents</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Methods</a></li></ul><a class="edit-page" href="https://github.com/philoez98/Turf.jl/blob/master/docs/src/methods.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Methods</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Methods-1" href="#Methods-1">Methods</a></h1><h2><a class="nav-anchor" id="Contents-1" href="#Contents-1">Contents</a></h2><ul><li><a href="#Booleans-1">Booleans</a></li><li><a href="#Conversion-1">Conversion</a></li><li><a href="#Grids-1">Grids</a></li><li><a href="#Measurement-1">Measurement</a></li><li><a href="#Misc-1">Misc</a></li><li><a href="#Transformation-1">Transformation</a></li></ul><h3><a class="nav-anchor" id="Booleans-1" href="#Booleans-1">Booleans</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.clockwise-Tuple{Union{Array{Array{Float64,1},1}, LineString}}" href="#Turf.clockwise-Tuple{Union{Array{Array{Float64,1},1}, LineString}}"><code>Turf.clockwise</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">clockwise(line::Union{LineString, Vector{Position}})::Bool</code></pre><p>Take a ring and return true or false whether or not the ring is clockwise or counter-clockwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; line = LineString([[0, 0], [1, 1], [1, 0], [0, 0]])
LineString(Array{Float64,1}[[0.0, 0.0], [1.0, 1.0], [1.0, 0.0], [0.0, 0.0]])

julia&gt; clockwise(line)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Booleans.jl#L1-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.concave-Tuple{Polygon}" href="#Turf.concave-Tuple{Polygon}"><code>Turf.concave</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">concave(poly::Polygon)::Bool</code></pre><p>Take a polygon and return true or false as to whether it is concave or not.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; poly = Polygon([[[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]]])
Polygon(Array{Array{Float64,1},1}[[[0.0, 0.0], [0.0, 1.0], [1.0, 1.0], [1.0, 0.0], [0.0, 0.0]]])

julia&gt; concave(poly)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Booleans.jl#L40-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.contains-Tuple{AbstractGeometry,AbstractGeometry}" href="#Turf.contains-Tuple{AbstractGeometry,AbstractGeometry}"><code>Turf.contains</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">contains(ft1::AbstractGeometry, ft2::AbstractGeometry)::Bool</code></pre><p>Return true if the second geometry is completely contained by the first geometry. The interiors of both geometries must intersect and, the interior and boundary of the secondary (geometry b) must not intersect the exterior of the primary (geometry a). <code>contains</code> returns the exact opposite result of <code>within</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; line = LineString([[1, 1], [1, 2], [1, 3], [1, 4]])
LineString(Array{Float64,1}[[1.0, 1.0], [1.0, 2.0], [1.0, 3.0], [1.0, 4.0]])

julia&gt; point = Point([1, 2])
Point([1.0, 2.0])

julia&gt; contains(line, point)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Booleans.jl#L297-L316">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.crosses-Tuple{AbstractGeometry,AbstractGeometry}" href="#Turf.crosses-Tuple{AbstractGeometry,AbstractGeometry}"><code>Turf.crosses</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia"> crosses(ft1::AbstractGeometry, ft2::AbstractGeometry)::Bool</code></pre><p>Return <code>true</code> if the intersection results in a geometry whose dimension is one less than the maximum dimension of the two source geometries and the intersection set is interior to both source geometries.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; line = LineString([[1, 1], [1, 2], [1, 3], [1, 4]])
LineString(Array{Float64,1}[[1.0, 1.0], [1.0, 2.0], [1.0, 3.0], [1.0, 4.0]])

julia&gt; line2 = LineString([[-2, 2], [4, 2]])
LineString(Array{Float64,1}[[-2.0, 2.0], [4.0, 2.0]])

julia&gt; crosses(line2, line)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Booleans.jl#L641-L659">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.disjoint-Tuple{AbstractGeometry,AbstractGeometry}" href="#Turf.disjoint-Tuple{AbstractGeometry,AbstractGeometry}"><code>Turf.disjoint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">disjoint(geom1::AbstractGeometry, geom2::AbstractGeometry)::Bool</code></pre><p>Return <code>true</code> if the intersection of the two geometries is an empty set.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; poly = Polygon([[[-1, 2], [3, 2], [3, 3], [-1, 3], [-1, 2]]])
Polygon(Array{Array{Float64,1},1}[[[-1.0, 2.0], [3.0, 2.0], [3.0, 3.0], [-1.0, 3.0], [-1.0, 2.0]]])

julia&gt; point = Point([1, 1])
Point([1.0, 1.0])

julia&gt; disjoint(poly, point)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Booleans.jl#L492-L508">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.line_intersects-Tuple{AbstractLineString,AbstractLineString}" href="#Turf.line_intersects-Tuple{AbstractLineString,AbstractLineString}"><code>Turf.line_intersects</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">line_intersects(line1::AbstractLineString, line2::AbstractLineString)</code></pre><p>Find a point that intersects LineStrings with two coordinates each.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; line1 = LineString([[124.584961,-12.768946],[126.738281,-17.224758]])
LineString(Array{Float64,1}[[124.585, -12.7689], [126.738, -17.2248]])

julia&gt; line2 = LineString([[123.354492,-15.961329],[127.22168,-14.008696]])
LineString(Array{Float64,1}[[123.354, -15.9613], [127.222, -14.0087]])

julia&gt; line_intersects(line1, line2)
Point([125.584, -14.8357])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Booleans.jl#L570-L586">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.parallel-Tuple{LineString,LineString}" href="#Turf.parallel-Tuple{LineString,LineString}"><code>Turf.parallel</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">parallel(line1::LineString, line2::LineString)::Bool</code></pre><p>Return <code>true</code> if each segment of <code>line1</code> is parallel to the correspondent segment of <code>line2</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; line1 = LineString([[9.170356, 45.477985], [9.164434, 45.482551], [9.166644, 45.484003]])
LineString(Array{Float64,1}[[9.17036, 45.478], [9.16443, 45.4826], [9.16664, 45.484]])

julia&gt; line2 = LineString([[9.169356, 45.477985], [9.163434, 45.482551], [9.165644, 45.484003]])
LineString(Array{Float64,1}[[9.16936, 45.478], [9.16343, 45.4826], [9.16564, 45.484]])

julia&gt; parallel(line1, line2)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Booleans.jl#L106-L122">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.point_in_polygon" href="#Turf.point_in_polygon"><code>Turf.point_in_polygon</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">point_in_polygon(point::Point, polygon::Union{Polygon, MultiPolygon}, ignoreBoundary::Bool=false)::Bool</code></pre><p>Take a Point and a Polygon and determine if the point resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; point = Point([-77, 44])
Point([-77.0, 44.0])

julia&gt; poly = Polygon([[ [-81, 41], [-81, 47], [-72, 47], [-72, 41], [-81, 41]]])
Polygon(Array{Array{Float64,1},1}[[[-81.0, 41.0], [-81.0, 47.0], [-72.0, 47.0], [-72.0, 41.0], [-81.0, 41.0]]])

julia&gt; point_in_polygon(point, poly)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Booleans.jl#L222-L239">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.point_on_line" href="#Turf.point_on_line"><code>Turf.point_on_line</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">point_on_line(point::Point, line::LineString, ignoreEndVertices::Bool=false)::Bool</code></pre><p>Return true if a point is on a line. Accept a optional parameter to ignore the start and end vertices of the linestring.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; point = Point([1,1])
Point([1.0, 1.0])

julia&gt; line = LineString([[0, 0], [3, 3], [4, 4]])
LineString(Array{Float64,1}[[0.0, 0.0], [3.0, 3.0], [4.0, 4.0]])

julia&gt; point_on_line(point, line)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Booleans.jl#L150-L167">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.within-Tuple{AbstractGeometry,AbstractGeometry}" href="#Turf.within-Tuple{AbstractGeometry,AbstractGeometry}"><code>Turf.within</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">within(ft1::AbstractGeometry, ft2::AbstractGeometry)::Bool</code></pre><p>Return <code>true</code> if the first geometry is completely within the second geometry. The interiors of both geometries must intersect and, the interior and boundary of the primary (geometry a) must not intersect the exterior of the secondary (geometry b). <code>within</code> returns the exact opposite result of <code>contains</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; line = LineString([[1, 1], [1, 2], [1, 3], [1, 4]])
LineString(Array{Float64,1}[[1.0, 1.0], [1.0, 2.0], [1.0, 3.0], [1.0, 4.0]])

julia&gt; point = Point([1, 2])
Point([1.0, 2.0])

julia&gt; within(point, line)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Booleans.jl#L418-L437">source</a></section><h3><a class="nav-anchor" id="Conversion-1" href="#Conversion-1">Conversion</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.area-Union{Tuple{T}, Tuple{T}} where T&lt;:Union{AbstractFeatureCollection, AbstractGeometry}" href="#Turf.area-Union{Tuple{T}, Tuple{T}} where T&lt;:Union{AbstractFeatureCollection, AbstractGeometry}"><code>Turf.area</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">area(geojson::T) where {T &lt;: Union{AbstractFeatureCollection, AbstractGeometry}}</code></pre><p>Take one or more features and return their area in square meters.</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/Utils.jl#L109-L112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.clean" href="#Turf.clean"><code>Turf.clean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">clean(geojson::AbstractFeature, mutate::Bool=false)</code></pre><p>Remove redundant coordinates from any GeoJSON Feature.</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/Utils.jl#L264-L268">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.clean" href="#Turf.clean"><code>Turf.clean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">clean(geojson::AbstractGeometry, mutate::Bool=false)</code></pre><p>Remove redundant coordinates from any GeoJSON Geometry.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; line = LineString([[0, 0], [0, 2], [0, 5], [0, 8], [0, 10], [0, 10]])
LineString(Array{Float64,1}[[0.0, 0.0], [0.0, 2.0], [0.0, 5.0], [0.0, 8.0], [0.0, 10.0], [0.0, 10.0]])

julia&gt; clean(line)
LineString(Array{Float64,1}[[0.0, 0.0], [0.0, 10.0]])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/Utils.jl#L195-L208">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.clean!-Tuple{AbstractFeature}" href="#Turf.clean!-Tuple{AbstractFeature}"><code>Turf.clean!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">clean!(geojson::AbstractFeature)</code></pre><p>Remove redundant coordinates from any GeoJSON Feature. It modifies the GeoJSON geometry in place.</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/Utils.jl#L271-L275">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.clean!-Tuple{AbstractGeometry}" href="#Turf.clean!-Tuple{AbstractGeometry}"><code>Turf.clean!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">clean!(geojson::AbstractGeometry)</code></pre><p>Remove redundant coordinates from any GeoJSON Geometry. It modifies the GeoJSON geometry in place.</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/Utils.jl#L257-L261">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.convert_area" href="#Turf.convert_area"><code>Turf.convert_area</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">convert_area(area::Real, originalUnit::String=&quot;meters&quot;, finalUnit::String=&quot;kilometers&quot;)::Real</code></pre><p>Convert an area to the requested unit.</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/Utils.jl#L49-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.convert_length" href="#Turf.convert_length"><code>Turf.convert_length</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">convert_length(length::Real, originalUnit::String=&quot;kilometers&quot;, finalUnit::String=&quot;kilometers&quot;)::Real</code></pre><p>Convert a length to the requested unit.</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/Utils.jl#L39-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.length_to_degrees" href="#Turf.length_to_degrees"><code>Turf.length_to_degrees</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">length_to_degrees(distance::Real, units::String=&quot;kilometers&quot;)::Real</code></pre><p>Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees. Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/Utils.jl#L29-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.length_to_radians" href="#Turf.length_to_radians"><code>Turf.length_to_radians</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">length_to_radians(distance::Real, units::String=&quot;kilometers&quot;)::Real</code></pre><p>Convert a distance measurement (assuming a spherical Earth) from a real-world unit to radians. Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/Utils.jl#L15-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.radians_to_length" href="#Turf.radians_to_length"><code>Turf.radians_to_length</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">radians_to_length(radians::Real, units::String=&quot;kilometers&quot;)::Real</code></pre><p>Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit. Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/Utils.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.to_WGS84-Tuple{Point}" href="#Turf.to_WGS84-Tuple{Point}"><code>Turf.to_WGS84</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">to_WGS84(pos::Point)</code></pre><p>Convert 900913 x/y values to lon/lat.</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/Utils.jl#L75-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.to_mercator-Tuple{Point}" href="#Turf.to_mercator-Tuple{Point}"><code>Turf.to_mercator</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">to_mercator(pos::Point)</code></pre><p>Convert lon/lat values to 900913 x/y.</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/Utils.jl#L87-L91">source</a></section><h3><a class="nav-anchor" id="Grids-1" href="#Grids-1">Grids</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.hexgrid-Union{Tuple{T}, Tuple{Array{T,1},T}, Tuple{Array{T,1},T,Union{Nothing, Polygon}}, Tuple{Array{T,1},T,Union{Nothing, Polygon},Bool}, Tuple{Array{T,1},T,Union{Nothing, Polygon},Bool,String}} where T&lt;:Real" href="#Turf.hexgrid-Union{Tuple{T}, Tuple{Array{T,1},T}, Tuple{Array{T,1},T,Union{Nothing, Polygon}}, Tuple{Array{T,1},T,Union{Nothing, Polygon},Bool}, Tuple{Array{T,1},T,Union{Nothing, Polygon},Bool,String}} where T&lt;:Real"><code>Turf.hexgrid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia"> hexgrid(bbox::Vector{T}, cellSide::T, mask::Union{Polygon, Nothing}=nothing, triangles::Bool=false, units::String=&quot;kilometers&quot;) where {T &lt;: Real}</code></pre><p>Take a bounding box and the diameter of the cell and return a FeatureCollection of flat-topped hexagons or triangles Polygon aligned in an &quot;odd-q&quot; vertical grid as described in <a href="http://www.redblobgames.com/grids/hexagons/">Hexagonal Grids</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Grids.jl#L160-L166">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.point_grid-Union{Tuple{T}, Tuple{Array{T,1},T}, Tuple{Array{T,1},T,Union{Nothing, Polygon}}, Tuple{Array{T,1},T,Union{Nothing, Polygon},String}} where T&lt;:Real" href="#Turf.point_grid-Union{Tuple{T}, Tuple{Array{T,1},T}, Tuple{Array{T,1},T,Union{Nothing, Polygon}}, Tuple{Array{T,1},T,Union{Nothing, Polygon},String}} where T&lt;:Real"><code>Turf.point_grid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">point_grid(bbox::Vector{T}, cellSide::T, mask::Union{Polygon, Nothing}=nothing, units::String=&quot;kilometers&quot;) where {T &lt;: Real}</code></pre><p>Create a Point grid from a bounding box</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; bbox = [-1, 2, 1, 3]
4-element Array{Int64,1}:
 -1
  2
  1
  3

julia&gt; point_grid(bbox, 100)
FeatureCollection{Feature}(Feature[Feature(Point([-0.899869, 2.05034]), Dict{String,Any}()), Feature(Point([-0.899869, 2.94966]), Dict{String,Any}()), Feature(Point([0.0, 2.05034]), Dict{String,Any}()), Feature(Point([0.0, 2.94966]), Dict{String,Any}()), Feature(Point([0.899869, 2.05034]), Dict{String,Any}()), Feature(Point([0.899869, 2.94966]), Dict{String,Any}())], nothing, nothing)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Grids.jl#L1-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.rectangle_grid-Union{Tuple{T}, Tuple{Array{T,1},T,T}, Tuple{Array{T,1},T,T,Union{Nothing, Polygon}}, Tuple{Array{T,1},T,T,Union{Nothing, Polygon},String}} where T&lt;:Real" href="#Turf.rectangle_grid-Union{Tuple{T}, Tuple{Array{T,1},T,T}, Tuple{Array{T,1},T,T,Union{Nothing, Polygon}}, Tuple{Array{T,1},T,T,Union{Nothing, Polygon},String}} where T&lt;:Real"><code>Turf.rectangle_grid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rectangle_grid(bbox::Vector{T}, width::T, height::T, mask::Union{Polygon, Nothing}=nothing, units::String=&quot;kilometers&quot;) where {T &lt;: Real}</code></pre><p>Create a grid of rectangles from a bounding box.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; bbox = [-1, 2, 1, 3]
4-element Array{Int64,1}:
 -1
  2
  1
  3

julia&gt; rectangle_grid(bbox, 150, 100)
FeatureCollection{Feature}(Feature[Feature(Polygon(Array{Array{Float64,1},1}[[[-0.674901, 2.05034], [-0.674901, 2.94966], [0.674901, 2.94966], [0.674901, 2.05034], [-0.674901, 2.05034]]]), Dict{String,Any}())], nothing, nothing)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Grids.jl#L64-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.square_grid-Union{Tuple{T}, Tuple{Array{T,1},T}, Tuple{Array{T,1},T,Union{Nothing, Polygon}}, Tuple{Array{T,1},T,Union{Nothing, Polygon},String}} where T&lt;:Real" href="#Turf.square_grid-Union{Tuple{T}, Tuple{Array{T,1},T}, Tuple{Array{T,1},T,Union{Nothing, Polygon}}, Tuple{Array{T,1},T,Union{Nothing, Polygon},String}} where T&lt;:Real"><code>Turf.square_grid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">square_grid(bbox::Vector{T}, cell_side::T, mask::Union{Polygon, Nothing}=nothing, units::String=&quot;kilometers&quot;) where {T &lt;: Real}</code></pre><p>Create a square grid from a bounding box.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; bbox = [-1, 2, 1, 3]
4-element Array{Int64,1}:
 -1
  2
  1
  3

julia&gt; square_grid(bbox, 100)
FeatureCollection{Feature}(Feature[Feature(Polygon(Array{Array{Float64,1},1}[[[-0.899869, 2.05034], [-0.899869, 2.94966], [0.0, 2.94966], [0.0, 2.05034], [-0.899869, 2.05034]]]), Dict{String,Any}()), Feature(Polygon(Array{Array{Float64,1},1}[[[0.0, 2.05034], [0.0, 2.94966], [0.899869, 2.94966], [0.899869, 2.05034], [0.0, 2.05034]]]), Dict{String,Any}())], nothing, nothing)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Grids.jl#L253-L270">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.triangle_grid-Union{Tuple{T}, Tuple{Array{T,1},T}, Tuple{Array{T,1},T,Union{Nothing, Polygon}}, Tuple{Array{T,1},T,Union{Nothing, Polygon},String}} where T&lt;:Real" href="#Turf.triangle_grid-Union{Tuple{T}, Tuple{Array{T,1},T}, Tuple{Array{T,1},T,Union{Nothing, Polygon}}, Tuple{Array{T,1},T,Union{Nothing, Polygon},String}} where T&lt;:Real"><code>Turf.triangle_grid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">triangle_grid(bbox::Vector{T}, cell_side::T, mask::Union{Polygon, Nothing}=nothing, units::String=&quot;kilometers&quot;) where {T &lt;: Real}</code></pre><p>Take a bounding box and a cell depth and returns a set of triangular Polygons in a grid.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; bbox = [-1, 2, 1, 3]
4-element Array{Int64,1}:
 -1
  2
  1
  3

julia&gt; triangle_grid(bbox, 200)
FeatureCollection{Feature}(Feature[Feature(Polygon(Array{Array{Float64,1},1}[[[-1.0, 2.0], [-1.0, 3.79864], [0.799737, 2.0], [-1.0, 2.0]]]), Dict{String,Any}()), Feature(Polygon(Array{Array{Float64,1},1}[[[-1.0, 3.79864], [0.799737, 3.79864], [0.799737, 2.0], [-1.0, 3.79864]]]), Dict{String,Any}()), Feature(Polygon(Array{Array{Float64,1},1}[[[0.799737, 2.0], [0.799737, 3.79864], [2.59947, 3.79864], [0.799737, 2.0]]]), Dict{String,Any}()), Feature(Polygon(Array{Array{Float64,1},1}[[[0.799737, 2.0], [2.59947, 3.79864], [2.59947, 2.0], [0.799737, 2.0]]]), Dict{String,Any}())], nothing, nothing)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Grids.jl#L275-L292">source</a></section><h3><a class="nav-anchor" id="Measurement-1" href="#Measurement-1">Measurement</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.distance" href="#Turf.distance"><code>Turf.distance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">distance(from::Position, to::Position, units::String=&quot;kilometers&quot;)</code></pre><p>Calculate the distance between two Points or Positions in degrees, radians, miles, or kilometers. The distance is calculated using the <a href="http://en.wikipedia.org/wiki/Haversine_formula">Haversine formula</a> to account for global curvature.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; point1 = Point([35, 45])
Point([35.0, 45.0])

julia&gt; point2 = Point([38, 43])
Point([38.0, 43.0])

julia&gt; distance(point1, point2)
327.1241022693492

julia&gt; distance(point1, point2, &quot;miles&quot;)
203.26549343667307

julia&gt; distance(point1, point2, &quot;degrees&quot;)
2.9384603841845878</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Distance.jl#L2-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.distance_to_segment" href="#Turf.distance_to_segment"><code>Turf.distance_to_segment</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">distance_to_segment(point::Point, first::Point, last::Point, units::String=&quot;degrees&quot;, method::String=&quot;planar&quot;)</code></pre><p>Return the distance between a point P on a segment AB.</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Distance.jl#L132-L136">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.distance_weight-Union{Tuple{}, Tuple{T}} where T&lt;:AbstractFeatureCollection" href="#Turf.distance_weight-Union{Tuple{}, Tuple{T}} where T&lt;:AbstractFeatureCollection"><code>Turf.distance_weight</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">distance_weight(; geojson::T, treshold::Real=10000, p::Integer=2, binary::Bool=false, alpha::Real=-1., standardization::Bool=false) where {T &lt;: AbstractFeatureCollection}</code></pre><p>Calculate the Minkowski p-norm distance between two Points.</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Distance.jl#L200-L204">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.midpoint-Tuple{Point,Point}" href="#Turf.midpoint-Tuple{Point,Point}"><code>Turf.midpoint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">midpoint(first::Point, second::Point)</code></pre><p>Take two Points and returns a point midway between them. The midpoint is calculated geodesically, meaning the curvature of the earth is taken into account.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; point = Point([35, 45])
Point([35.0, 45.0])

julia&gt; point1 = Point([33, 42])
Point([33.0, 42.0])

julia&gt; midpoint(point, point1)
Point([33.9751, 43.5044])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Distance.jl#L299-L316">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.nearestpoint-Tuple{Point,Array{Point,1}}" href="#Turf.nearestpoint-Tuple{Point,Array{Point,1}}"><code>Turf.nearestpoint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">nearestpoint(target::Point, points::Vector{Point})</code></pre><p>Take a reference Point and an array of Points and return the point from the array closest to the reference. This calculation is geodesic.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; point = Point([35, 45])
Point([35.0, 45.0])

julia&gt; point1 = Point([33, 42])
Point([33.0, 42.0])

julia&gt; point2 = Point([39, 41])
Point([39.0, 41.0])

julia&gt; point3 = Point([35, 39])
Point([35.0, 39.0])

julia&gt; nearestpoint(point, [point1, point2, point3])
Point([33.0, 42.0])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Distance.jl#L160-L183">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.pnorm_distance" href="#Turf.pnorm_distance"><code>Turf.pnorm_distance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pnorm_distance(point1::Point, point2::Point, p::Integer=2)::Real</code></pre><p>Calculate the Minkowski p-norm distance between two Points.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; point = Point([35, 45])
Point([35.0, 45.0])

julia&gt; point1 = Point([33, 42])
Point([33.0, 42.0])

julia&gt; pnorm_distance(point, point1)
3.605551275463989

julia&gt; pnorm_distance(point, point1, 1)
5.0

julia&gt; pnorm_distance(point, point1, 3)
3.2710663101885897</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Distance.jl#L263-L285">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.point_to_line_distance" href="#Turf.point_to_line_distance"><code>Turf.point_to_line_distance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">point_to_line_distance(point::Point, line::LineString, units::String=&quot;kilometers&quot;, method::String=&quot;geodesic&quot;)</code></pre><p>Return the minimum distance between a Point and a LineString, being the distance from a line the minimum distance between the point and any segment of the <code>LineString</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; point = Point([35, 45])
Point([35.0, 45.0])

julia&gt; line = LineString([[35, 42], [38, 42.5], [40, 43]])
LineString(Array{Float64,1}[[35.0, 42.0], [38.0, 42.5], [40.0, 43.0]])

julia&gt; point_to_line_distance(point, line)
326.92768049303146

julia&gt; point_to_line_distance(point, line, &quot;degrees&quot;, &quot;planar&quot;)
2.936700172184462

julia&gt; point_to_line_distance(point, line, &quot;degrees&quot;)
2.9366959846668</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Distance.jl#L91-L114">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.rhumb_distance" href="#Turf.rhumb_distance"><code>Turf.rhumb_distance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rhumb_distance(from::Position, to::Position, units::String=&quot;kilometers&quot;)</code></pre><p>Calculate the distance along a rhumb line between two Points or Positions in degrees, radians, miles, or kilometers.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; point1 = Point([35, 45])
Point([35.0, 45.0])

julia&gt; point2 = Point([38, 43])
Point([38.0, 43.0])

julia&gt; rhumb_distance(point1, point2)
327.1421400706353

julia&gt; rhumb_distance(point1, point2, &quot;miles&quot;)
203.2767016067636

julia&gt; rhumb_distance(point1, point2, &quot;degrees&quot;)
2.9386224124916716</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Distance.jl#L41-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.bearing" href="#Turf.bearing"><code>Turf.bearing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bearing(start::Position, stop::Position, final::Bool=false)</code></pre><p>Take two Points or Positions and finds the geographic bearing between them, i.e. the angle measured in degrees from the north line (0 degrees).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; start = Position([-75, 45])
2-element Array{Float64,1}:
 -75.0
  45.0

julia&gt; stop = Position([20, 60])
2-element Array{Float64,1}:
 20.0
 60.0

julia&gt; bearing(start, stop)
37.75495852601734</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Bearing.jl#L83-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.bearing_to_azimuth-Tuple{Real}" href="#Turf.bearing_to_azimuth-Tuple{Real}"><code>Turf.bearing_to_azimuth</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bearing_to_azimuth(bearing::Real)::Real</code></pre><p>Convert any bearing angle from the north line direction (positive clockwise) and return an angle between 0-360 degrees (positive clockwise), 0 being the north line.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; bearing_to_azimuth(40)
40

julia&gt; bearing_to_azimuth(-105)
255

julia&gt; bearing_to_azimuth(410)
50</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Bearing.jl#L1-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.rhumb_bearing" href="#Turf.rhumb_bearing"><code>Turf.rhumb_bearing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rhumb_bearing(start::Position, stop::Position, final::Bool=false)</code></pre><p>Take two Positions and finds the bearing angle between them along a Rhumb line i.e. the angle measured in degrees start the north line (0 degrees).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; start = Position([-75, 45])
2-element Array{Float64,1}:
 -75.0
  45.0

julia&gt; stop = Position([20, 60])
2-element Array{Float64,1}:
 20.0
 60.0

julia&gt; rhumb_bearing(start, stop)
75.28061364784332</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Bearing.jl#L28-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.angle_adjacent" href="#Turf.angle_adjacent"><code>Turf.angle_adjacent</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">angle_adjacent(start::Position, mid::Position, stop::Position, explementary::Bool=false, mercator::Bool=false)</code></pre><p>Find the angle formed by two adjacent segments defined by 3 points. The result will be the (positive clockwise) angle with origin on the <code>start-mid</code> segment, or its explementary angle if required.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; p1 = Point([-35, 55])
Point([-35.0, 55.0])

julia&gt; p2 = Point([-34.8, 57.5])
Point([-34.8, 57.5])

julia&gt; p3 = Point([-33.4, 59.1])
Point([-33.4, 59.1])

julia&gt; angle_adjacent(p1, p2, p3, false, false)
202.8279033760424

julia&gt; angle_adjacent(p1, p2, p3, true, false) # explementary angle
157.1720966239576</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Angle.jl#L1-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.center-Union{Tuple{T}, Tuple{T}} where T&lt;:Union{AbstractFeatureCollection, AbstractGeometry}" href="#Turf.center-Union{Tuple{T}, Tuple{T}} where T&lt;:Union{AbstractFeatureCollection, AbstractGeometry}"><code>Turf.center</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">center(geojson::T) where {T &lt;: AbstractGeometry}</code></pre><p>Take a GeoJson Geometry and return the absolute center point.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; line = LineString([[1, 2], [4, 6], [8, 9.5], [12, 13.4]])
LineString(Array{Float64,1}[[1.0, 2.0], [4.0, 6.0], [8.0, 9.5], [12.0, 13.4]])

julia&gt; center(line)
Point([6.5, 7.7])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Centering.jl#L96-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.centroid-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractFeatureCollection" href="#Turf.centroid-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractFeatureCollection"><code>Turf.centroid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">centroid([geojson::T])::Point where {T &lt;: AbstractFeatureCollection}</code></pre><p>Takes one or more features and calculates the centroid using the mean of all vertices. This lessens the effect of small islands and artifacts when calculating the centroid of a set of polygons.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; line = LineString([[1, 2], [4, 6], [8, 9.5], [12, 13.4]])
LineString(Array{Float64,1}[[1.0, 2.0], [4.0, 6.0], [8.0, 9.5], [12.0, 13.4]])

julia&gt; centroid(line)
Point([6.25, 7.725])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Centering.jl#L47-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.centroid-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractGeometry" href="#Turf.centroid-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractGeometry"><code>Turf.centroid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">centroid([geojson::T])::Point where {T &lt;: AbstractGeometry}</code></pre><p>Takes one or more features and calculates the centroid using the mean of all vertices. This lessens the effect of small islands and artifacts when calculating the centroid of a set of polygons.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; line = LineString([[1, 2], [4, 6], [8, 9.5], [12, 13.4]])
LineString(Array{Float64,1}[[1.0, 2.0], [4.0, 6.0], [8.0, 9.5], [12.0, 13.4]])

julia&gt; centroid(line)
Point([6.25, 7.725])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Centering.jl#L1-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.masscenter-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractGeometry" href="#Turf.masscenter-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractGeometry"><code>Turf.masscenter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">masscenter(geojson::T) where {T &lt;: AbstractGeometry}</code></pre><p>Take any GeoJson Geometry and return its <a href="https://en.wikipedia.org/wiki/Center_of_mass">center of mass</a> using this formula: <a href="https://en.wikipedia.org/wiki/Centroid#Centroid_of_polygon">Centroid of Polygon</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; line = LineString([[1, 2], [4, 6], [8, 9.5], [12, 13.4]])
LineString(Array{Float64,1}[[1.0, 2.0], [4.0, 6.0], [8.0, 9.5], [12.0, 13.4]])

julia&gt; masscenter(line)
Point([6.25, 7.725])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Centering.jl#L119-L133">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.meancenter-Union{Tuple{T}, Tuple{T}, Tuple{T,Real}} where T&lt;:Union{AbstractFeatureCollection, AbstractGeometry}" href="#Turf.meancenter-Union{Tuple{T}, Tuple{T}, Tuple{T,Real}} where T&lt;:Union{AbstractFeatureCollection, AbstractGeometry}"><code>Turf.meancenter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">meancenter(geojson::T, weight::Real=1.) where {T &lt;: Union{AbstractGeometry, AbstractFeatureCollection}}</code></pre><p>Take a GeoJson Geometry and return the mean center. Can be weighted.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; line = LineString([[1, 2], [4, 6], [8, 9.5], [12, 13.4]])
LineString(Array{Float64,1}[[1.0, 2.0], [4.0, 6.0], [8.0, 9.5], [12.0, 13.4]])

julia&gt; meancenter(line)
Point([6.25, 7.725])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Centering.jl#L183-L196">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.mediancenter-Union{Tuple{T}, Tuple{T}, Tuple{T,Real}, Tuple{T,Real,Real}, Tuple{T,Real,Real,Integer}} where T&lt;:AbstractFeatureCollection" href="#Turf.mediancenter-Union{Tuple{T}, Tuple{T}, Tuple{T,Real}, Tuple{T,Real,Real}, Tuple{T,Real,Real,Integer}} where T&lt;:AbstractFeatureCollection"><code>Turf.mediancenter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">mediancenter(geojson::T, weight::Real=1., tol::Real=0.001, count::Integer=10) where {T &lt;: AbstractFeatureCollection}</code></pre><p>Take a FeatureCollection of points and calculate the median center, algorithimically. The median center is understood as the point that is requires the least total travel from all other points.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; fc = FeatureCollection([Feature(Point([0, 0])),Feature(Point([9, 9])), Feature(Point([9.25, 9.25])),
             Feature(Point([9.5, 9.5])), Feature(Point([9.75, 9.75])), Feature(Point([10, 10]))])
FeatureCollection{Feature}(Feature[Feature(Point([0.0, 0.0]), Dict{String,Any}()), Feature(Point([9.0, 9.0]), Dict{String,Any}()), Feature(Point([9.25, 9.25]), Dict{String,Any}()), Feature(Point([9.5, 9.5]), Dict{String,Any}()), Feature(Point([9.75, 9.75]), Dict{String,Any}()), Feature(Point([10.0, 10.0]), Dict{String,Any}())], nothing, nothing)

julia&gt; mediancenter(fc)
Point([9.25425, 9.25425])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Centering.jl#L261-L277">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.destination" href="#Turf.destination"><code>Turf.destination</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">destination(origin::Position, distance::Real, bearing::Real, units::String=&quot;kilometers&quot;)</code></pre><p>Take a Point or a Position and calculate the location of a destination point given a distance in degrees, radians, miles, or kilometers; and bearing in degrees. The destination is calculated using the <a href="http://en.wikipedia.org/wiki/Haversine_formula">Haversine formula</a> to account for global curvature.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; point = Point([-75, 38])
Point([-75.0, 38.0])

julia&gt; destination(point, 100, 0)
Point([-75.0, 38.8993])

julia&gt; destination(point, 100, 45)
Point([-74.1859, 38.6331])

julia&gt; destination(point, 50, 0, &quot;miles&quot;)
Point([-75.0, 38.7237])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Destination.jl#L1-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.rhumb_destination" href="#Turf.rhumb_destination"><code>Turf.rhumb_destination</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rhumb_destination(origin::Position, distance::Real, bearing::Real, units::String=&quot;kilometers&quot;)</code></pre><p>Take a Point or a Position and return the destination Point having travelled the given distance along a Rhumb line from the origin Point with the (varant) given bearing.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; point = Point([-75, 38])
Point([-75.0, 38.0])

julia&gt; rhumb_destination(point, 100, 0)
Point([-75.0, 38.8993])

julia&gt; rhumb_destination(point, 100, 45)
Point([-74.1895, 38.6359])

julia&gt; rhumb_destination(point, 50, 0, &quot;miles&quot;)
Point([-75.0, 38.7237])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Destination.jl#L38-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.ellipse-Tuple{}" href="#Turf.ellipse-Tuple{}"><code>Turf.ellipse</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ellipse(; center::Point, xAxis::Real, yAxis::Real, steps::Integer=64, angle::Real=0., pivot::Union{Point, Nothing}=nothing, units::String=&quot;kilometers&quot;)</code></pre><p>Take a Point and calculates the ellipse polygon given two semi-axes expressed in variable units and steps for precision.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; center = Point([10, 45])
Point([10.0, 45.0])

julia&gt; ellipse(center=center, xAxis=20, yAxis=7.5, steps=10)
Polygon(Array{Array{Float64,1},1}[[[10.0872, 45.0634], [10.0218, 45.0672], [9.97817, 45.0672], [9.91279, 45.0634], [9.74563, 45.0], [9.91279, 44.9366], [9.97817, 44.9328], [10.0218, 44.9328], [10.0872, 44.9366], [10.2544, 45.0], [10.0872, 45.0634]]])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Ellipse.jl#L1-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.circle-Tuple{}" href="#Turf.circle-Tuple{}"><code>Turf.circle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">circle(; center::Union{Point, Position}, radius::Real=5., steps::Integer=64, units::String=&quot;kilometers&quot;)</code></pre><p>Take a Point or a Position and calculate the circle polygon given a radius in degrees, radians, miles, or kilometers; and steps for precision.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; point = Point([35, 45])
Point([35.0, 45.0])

julia&gt; circle(center=point, steps=5)
Polygon(Array{Array{Float64,1},1}[[[34.9395, 45.0139], [34.9626, 44.9636], [35.0374, 44.9636], [35.0605, 45.0139], [35.0, 45.045], [34.9395, 45.0139]]])

julia&gt; circle(center=point, radius=2.5, steps=5, units=&quot;degrees&quot;)
Polygon(Array{Array{Float64,1},1}[[[31.5893, 45.7231], [32.99, 42.9571], [37.01, 42.9571], [38.4107, 45.7231], [35.0, 47.5029], [31.5893, 45.7231]]])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Circle.jl#L1-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.sector" href="#Turf.sector"><code>Turf.sector</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sector(center::Point, radius::Real, bearing1::Real, bearing2::Real, steps::Integer=64, units::String=&quot;kilometers&quot;)</code></pre><p>Creates a circular sector of a circle of given radius and center Point, between (clockwise) bearing1 and bearing2; 0 bearing is North of center point, positive clockwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; point = Point([35, 45])
Point([35.0, 45.0])

julia&gt; sector(point, 5, 0, 0.5, 5)
Polygon(Array{Array{Float64,1},1}[[[35.0, 45.0], [35.0, 45.045], [35.0006, 45.045], [35.0, 45.0]]])

julia&gt; sector(point, 5, 0, 270, 5)
Polygon(Array{Array{Float64,1},1}[[[35.0, 45.0], [35.0, 45.045], [35.0605, 45.0139], [35.0374, 44.9636], [34.9626, 44.9636], [34.9364, 45.0], [35.0, 45.0]]])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Circle.jl#L36-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.linearc" href="#Turf.linearc"><code>Turf.linearc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">linearc(center::Point, radius::Real, bearing1::Real, bearing2::Real, steps::Real=64., units::String=&quot;kilometers&quot;)</code></pre><p>Create a circular arc, of a circle of the given radius and center point, between bearing1 and bearing2; 0 bearing is North of center point, positive clockwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; point = Point([35, 45])
Point([35.0, 45.0])

julia&gt; linearc(point, 5, 0, 10, 5)
LineString(Array{Float64,1}[[35.0, 45.045], [35.0111, 45.0443]])

julia&gt; linearc(point, 5, 0, 270, 5)
LineString(Array{Float64,1}[[35.0, 45.045], [35.0605, 45.0139], [35.0374, 44.9636], [34.9626, 44.9636], [34.9364, 45.0]])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Lines.jl#L57-L74">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.linesegment-Tuple{LineString}" href="#Turf.linesegment-Tuple{LineString}"><code>Turf.linesegment</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">linesegment(geojson::LineString)</code></pre><p>Create a 2-vertex LineString segments from a LineString.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; line = LineString([[0, 1], [2, 3], [3, 3]])
LineString(Array{Float64,1}[[0.0, 1.0], [2.0, 3.0], [3.0, 3.0]])

julia&gt; linesegment(line)
2-element Array{LineString,1}:
 LineString(Array{Float64,1}[[0.0, 1.0], [2.0, 3.0]])
 LineString(Array{Float64,1}[[2.0, 3.0], [3.0, 3.0]])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Lines.jl#L27-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.square-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Real" href="#Turf.square-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Real"><code>Turf.square</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">square(bbox::Vector{T}) where {T &lt;: Real}</code></pre><p>Take a bounding box and calculates the minimum square bounding box that would contain the input.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; bbox = [-1, 1, 2, 3.5]
4-element Array{Float64,1}:
 -1.0
  1.0
  2.0
  3.5

julia&gt; square(bbox)
4-element Array{Float64,1}:
 -1.0
  0.75
  2.0
  3.75</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Square.jl#L1-L22">source</a></section><h3><a class="nav-anchor" id="Misc-1" href="#Misc-1">Misc</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.bbox-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractFeature" href="#Turf.bbox-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractFeature"><code>Turf.bbox</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia"> bbox(geojson::T) where {T&lt;: AbstractFeature}</code></pre><p>Take a Feature and return a bounding box around its geometry.</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/BBox.jl#L127-L131">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.bbox-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractFeatureCollection" href="#Turf.bbox-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractFeatureCollection"><code>Turf.bbox</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bbox(geojson::T) where {T&lt;:AbstractFeatureCollection}</code></pre><p>Take a set of features, calculate the bbox of all input features, and returns a bounding box.</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/BBox.jl#L7-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.bbox-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractGeometry" href="#Turf.bbox-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractGeometry"><code>Turf.bbox</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bbox(geojson::T) where {T &lt;: AbstractGeometry}</code></pre><p>Take a GeoJSON Geometry and calculate its bounding box.</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/BBox.jl#L68-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.bbox_polygon-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Real" href="#Turf.bbox_polygon-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Real"><code>Turf.bbox_polygon</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bbox_polygon(bbox::Vector{T}) where {T &lt;: Real}</code></pre><p>Take a bbox and return an equivalent Polygon.</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/BBox.jl#L135-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.bezier-Tuple{LineString}" href="#Turf.bezier-Tuple{LineString}"><code>Turf.bezier</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bezier(line::LineString; resolution::Real=10000, sharpness::Real=0.85)</code></pre><p>Take a LineString and returns a curved version by applying a <a href="http://en.wikipedia.org/wiki/B%C3%A9zier_spline">Bezier spline</a> algorithm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/BezierSpline.jl#L1-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.planepoint-Tuple{Point,Polygon}" href="#Turf.planepoint-Tuple{Point,Polygon}"><code>Turf.planepoint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">planepoint(point::Point, triangle::Polygon)</code></pre><p>Take a triangular plane as a Polygon and a Point within that triangle and returns the z-value at that point.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; point = Point([-175, 22])
Point([-175.0, 22.0])

julia&gt; triangle = Polygon([[-174.55, 32.54, 55], [-186.94, 17.64, 24.5], [-167.95, 17.81, 33.6], [-174.55, 32.54, 55]])
Polygon(Array{Array{Float64,1},1}[[[-174.55, 32.54, 55.0], [-186.94, 17.64, 24.5], [-167.95, 17.81, 33.6], [-174.55, 32.54, 55.0]]])

julia&gt; planepoint(point, triangle)
37.28550123965308</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Planes.jl#L1-L18">source</a></section><h3><a class="nav-anchor" id="Transformation-1" href="#Transformation-1">Transformation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.combine-Tuple{FeatureCollection}" href="#Turf.combine-Tuple{FeatureCollection}"><code>Turf.combine</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">combine([ft::FeatureCollection])</code></pre><p>Combine a FeatureCollection of Point, LineString, or Polygon features into MultiPoint, MultiLineString, or MultiPolygon features.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; l1 = LineString([[102.0,-10.0],[130.0,4.0]])
LineString(Array{Float64,1}[[102.0, -10.0], [130.0, 4.0]])

julia&gt; l2 = LineString([[40.0,-20.0],[150.0,18.0]])
LineString(Array{Float64,1}[[40.0, -20.0], [150.0, 18.0]])

julia&gt; combine(FeatureCollection([Feature(l1), Feature(l2)]))
FeatureCollection{Feature}(Feature[Feature(MultiLineString(Array{Array{Float64,1},1}[[[102.0, -10.0], [130.0, 4.0], [40.0, -20.0], [150.0, 18.0]]]), Dict{String,Any}())], nothing, nothing)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Transformations.jl#L661-L678">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.convert_to" href="#Turf.convert_to"><code>Turf.convert_to</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">convert_to([geojson::AbstractGeometry[, projection::String]], mutate::Bool=false)</code></pre><p>Convert a GeoJSON geojsonect to the defined <code>projection</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Transformations.jl#L616-L620">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.explode-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T&lt;:Union{AbstractFeatureCollection, AbstractGeometry}" href="#Turf.explode-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T&lt;:Union{AbstractFeatureCollection, AbstractGeometry}"><code>Turf.explode</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">explode([geojson::T], pointsOnly::Bool=false)::FeatureCollection where {T &lt;: Union{AbstractFeatureCollection, AbstractGeometry}}</code></pre><p>Takes a Geometry or a FeatureCollection and returns all positions as Points.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; poly = Polygon([[[100, 0], [101, 0], [101, 1], [100, 1], [100, 0]]])
Polygon(Array{Array{Float64,1},1}[[[100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0]]])

julia&gt; explode(poly, true)
5-element Array{Point,1}:
 Point([100.0, 0.0])
 Point([101.0, 0.0])
 Point([101.0, 1.0])
 Point([100.0, 1.0])
 Point([100.0, 0.0])
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Transformations.jl#L272-L291">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.flip-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T&lt;:Union{AbstractFeature, AbstractGeometry}" href="#Turf.flip-Union{Tuple{T}, Tuple{T}, Tuple{T,Bool}} where T&lt;:Union{AbstractFeature, AbstractGeometry}"><code>Turf.flip</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">flip([geojson::T], mutate::Bool=false) where {T &lt;: Union{AbstractFeature, AbstractGeometry}}</code></pre><p>Take input Features and Geometries and flips all of their coordinates from <code>[x, y]</code> to <code>[y, x]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; point = Point([77.34374999999999,43.58039085560784,3000])
Point([77.3437, 43.5804, 3000.0])

julia&gt; flip(point)
Point([43.5804, 77.3437, 3000.0])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Transformations.jl#L342-L355">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.lineclip-Union{Tuple{P}, Tuple{T}, Tuple{Array{P,1},Array{T,1}}} where P&lt;:AbstractPoint where T&lt;:Real" href="#Turf.lineclip-Union{Tuple{P}, Tuple{T}, Tuple{Array{P,1},Array{T,1}}} where P&lt;:AbstractPoint where T&lt;:Real"><code>Turf.lineclip</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Cohen-Sutherland line clippign algorithm, adapted to efficiently to handle polylines rather than just segments</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Transformations.jl#L403-L406">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.polygon_tangents-Tuple{Point,Polygon}" href="#Turf.polygon_tangents-Tuple{Point,Polygon}"><code>Turf.polygon_tangents</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">polygon_tangents(pt::Point, poly::Polygon)</code></pre><p>Finds the tangents of a Polygon from a Point.</p><p><strong>Examples</strong></p><p>```jldoctest julia&gt; point = Point([92.46093749999999,54.67383096593114]) Point([92.4609, 54.6738])</p><p>julia&gt; poly = Polygon([[[100, 0], [101, 0], [101, 1], [100, 1], [100, 0]]]) Polygon(Array{Array{Float64,1},1}[[[100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0]]])</p><p>julia&gt; poly = Polygon([[[48.1641, 20.6328], [76.6406, 20.6328], [76.6406, 38.8226], [48.1641, 38.8226], [48.1641, 20.6328]]]) Polygon(Array{Array{Float64,1},1}[[[48.1641, 20.6328], [76.6406, 20.6328], [76.6406, 38.8226], [48.1641, 38.8226], [48.1641, 20.6328]]])</p><p>julia&gt; polygon_tangents(point, poly) FeatureCollection{Feature}(Feature[Feature(Point([48.1641, 38.8226]), Dict{String,Any}()), Feature(Point([76.6406, 20.6328]), Dict{String,Any}())], nothing, nothing)  ```</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Transformations.jl#L512-L531">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.polygon_to_line-Tuple{Polygon}" href="#Turf.polygon_to_line-Tuple{Polygon}"><code>Turf.polygon_to_line</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">polygon_to_line([poly::Polygon])</code></pre><p>Converts a Polygon to LineString or MultiLineString</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; poly = Polygon([[[-2.275543, 53.464547],[-2.275543, 53.489271],[-2.215118, 53.489271],[-2.215118, 53.464547],[-2.275543, 53.464547]]])
Polygon(Array{Array{Float64,1},1}[[[-2.27554, 53.4645], [-2.27554, 53.4893], [-2.21512, 53.4893], [-2.21512, 53.4645], [-2.27554, 53.4645]]])

julia&gt; polygon_to_line(poly)
LineString(Array{Float64,1}[[-2.27554, 53.4645], [-2.27554, 53.4893], [-2.21512, 53.4893], [-2.21512, 53.4645], [-2.27554, 53.4645]])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Transformations.jl#L593-L606">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.polygonclip-Union{Tuple{T}, Tuple{P}, Tuple{Array{P,1},Array{T,1}}} where T&lt;:Real where P&lt;:AbstractPoint" href="#Turf.polygonclip-Union{Tuple{T}, Tuple{P}, Tuple{Array{P,1},Array{T,1}}} where T&lt;:Real where P&lt;:AbstractPoint"><code>Turf.polygonclip</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Sutherland-Hodgeman polygon clipping algorithm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Transformations.jl#L455-L457">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.scale" href="#Turf.scale"><code>Turf.scale</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">scale([feature::Feature[, factor::Real]], origin::String=&quot;centroid&quot;)</code></pre><p>Scale a Feature.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; feature = Feature(Polygon([[[0, 29], [3.5, 29], [2.5, 32], [0, 29]]]))
Feature(Polygon(Array{Array{Float64,1},1}[[[0.0, 29.0], [3.5, 29.0], [2.5, 32.0], [0.0, 29.0]]]), Dict{String,Any}())

julia&gt; scale(feature, 0.1)
Feature(Polygon(Array{Array{Float64,1},1}[[[1.3495, 29.675], [1.70067, 29.675], [1.59896, 29.975], [1.3495, 29.675]]]), Dict{String,Any}())</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Transformations.jl#L173-L186">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.simplify" href="#Turf.simplify"><code>Turf.simplify</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">simplify(geojson::FeatureCollection, tolerance::Real=1., hq::Bool=false, mutate::Bool=false)</code></pre><p>Take a FeatureCollection and return a simplified version. Internally uses an adaptation of <a href="http://mourner.github.io/simplify-js/">simplify-js</a> to perform simplification using the Ramer-Douglas-Peucker algorithm.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; poly = Polygon([[
    [-70.603637, -33.399918],
    [-70.614624, -33.395332],
    [-70.639343, -33.392466],
    [-70.659942, -33.394759],
    [-70.683975, -33.404504],
    [-70.697021, -33.419406],
    [-70.701141, -33.434306],
    [-70.700454, -33.446339],
    [-70.694274, -33.458369],
    [-70.682601, -33.465816],
    [-70.668869, -33.472117],
    [-70.646209, -33.473835],
    [-70.624923, -33.472117],
    [-70.609817, -33.468107],
    [-70.595397, -33.458369],
    [-70.587158, -33.442901],
    [-70.587158, -33.426283],
    [-70.590591, -33.414248],
    [-70.594711, -33.406224],
    [-70.603637, -33.399918]]])

julia&gt; simplify(poly, 0.01)
Polygon(Array{Array{Float64,1},1}[[[-70.6036, -33.3999], [-70.684, -33.4045], [-70.7011, -33.4343], [-70.6943, -33.4584], [-70.6689, -33.4721], [-70.6098, -33.4681], [-70.5872, -33.4429], [-70.6036, -33.3999]]])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Transformations.jl#L772-L805">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.simplify" href="#Turf.simplify"><code>Turf.simplify</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">simplify(geojson::AbstractFeature, tolerance::Real=1., hq::Bool=false, mutate::Bool=false)</code></pre><p>Take a GeoJSON Feature and return a simplified version. Internally uses an adaptation of <a href="http://mourner.github.io/simplify-js/">simplify-js</a> to perform simplification using the Ramer-Douglas-Peucker algorithm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Transformations.jl#L851-L856">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.simplify" href="#Turf.simplify"><code>Turf.simplify</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">simplify(geojson::AbstractGeometry, tolerance::Real=1., hq::Bool=false, mutate::Bool=false)</code></pre><p>Take a GeoJSON Geometry and return a simplified version. Internally uses an adaptation of <a href="http://mourner.github.io/simplify-js/">simplify-js</a> to perform simplification using the Ramer-Douglas-Peucker algorithm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Transformations.jl#L830-L835">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.simplify!" href="#Turf.simplify!"><code>Turf.simplify!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">simplify(geojson::AbstractGeometry, tolerance::Real=1., hq::Bool=false)</code></pre><p>Take a GeoJSON Geometry and return a simplified version, modifying the original Geometry. Internally uses an adaptation of <a href="http://mourner.github.io/simplify-js/">simplify-js</a> to perform simplification using the Ramer-Douglas-Peucker algorithm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Transformations.jl#L842-L847">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.simplify!" href="#Turf.simplify!"><code>Turf.simplify!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">simplify(geojson::AbstractFeature, tolerance::Real=1., hq::Bool=false)</code></pre><p>Take a GeoJSON Feature and return a simplified version, modifying the original Feature. Internally uses an adaptation of <a href="http://mourner.github.io/simplify-js/">simplify-js</a> to perform simplification using the Ramer-Douglas-Peucker algorithm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Transformations.jl#L860-L865">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.simplify!" href="#Turf.simplify!"><code>Turf.simplify!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">simplify(geojson::FeatureCollection, tolerance::Real=1., hq::Bool=false)</code></pre><p>Take a FeatureCollection and return a simplified version, modifying the original FeatureCollection. Internally uses an adaptation of <a href="http://mourner.github.io/simplify-js/">simplify-js</a> to perform simplification using the Ramer-Douglas-Peucker algorithm.</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Transformations.jl#L821-L826">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.tag-Tuple{FeatureCollection,FeatureCollection,String,String}" href="#Turf.tag-Tuple{FeatureCollection,FeatureCollection,String,String}"><code>Turf.tag</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tag(fc1::FeatureCollection, fc2::FeatureCollection, in_field::String, out_field::String)::FeatureCollection</code></pre><p>Take a set of Points and a set of Polygons and performs a spatial join.</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Transformations.jl#L749-L753">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.transform_rotate-Union{Tuple{}, Tuple{T}} where T&lt;:AbstractGeometry" href="#Turf.transform_rotate-Union{Tuple{}, Tuple{T}} where T&lt;:AbstractGeometry"><code>Turf.transform_rotate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">transform_rotate([geojson::T[, angle::Real], pivot::Point=nothing, mutate::Bool=false) where {T &lt;: AbstractGeometry}</code></pre><p>Rotates any geojson Feature or Geometry of a specified angle, around its <code>centroid</code> or a given <code>pivot</code> point; all rotations follow the right-hand rule.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; point = Point([-75.69926351308823,45.43145021122502])
Point([-75.6993, 45.4315])

julia&gt; transform_rotate(geojson=point, angle=80., pivot=Point([-75.6, 45.3]))
Point([-75.433, 45.3915])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Transformations.jl#L3-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.transform_scale-Union{Tuple{T}, Tuple{T,Real}, Tuple{T,Real,String}, Tuple{T,Real,String,Bool}} where T&lt;:AbstractFeatureCollection" href="#Turf.transform_scale-Union{Tuple{T}, Tuple{T,Real}, Tuple{T,Real,String}, Tuple{T,Real,String,Bool}} where T&lt;:AbstractFeatureCollection"><code>Turf.transform_scale</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">transform_scale([geojson::T[, factor::Float64]], origin::String=&quot;centroid&quot;) where {T &lt;: AbstractFeatureCollection}</code></pre><p>Scale a GeoJson from a given point by a factor of scaling (ex: factor=2 would make the GeoJson 200% larger). If a FeatureCollection is provided, the origin point will be calculated based on each individual Feature.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; coll = FeatureCollection([Feature(Point([-75.69926351308823,45.43145021122502])), Feature(Polygon([[[0, 29], [3.5, 29], [2.5, 32], [0, 29]]]))])
FeatureCollection{Feature}(Feature[Feature(Point([-75.6993, 45.4315]), Dict{String,Any}()), Feature(Polygon(Array{Array{Float64,1},1}[[[0.0, 29.0], [3.5, 29.0], [2.5, 32.0], [0.0, 29.0]]]), Dict{String,Any}())], nothing, nothing)

julia&gt; transform_scale(coll, 0.1)
FeatureCollection{Feature}(Feature[Feature(Point([-75.6993, 45.4315]), Dict{String,Any}()), Feature(Polygon(Array{Array{Float64,1},1}[[[1.3495, 29.675], [1.70067, 29.675], [1.59896, 29.975], [1.3495, 29.675]]]), Dict{String,Any}())], nothing, nothing)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Transformations.jl#L140-L154">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.transform_translate-Union{Tuple{R}, Tuple{T}, Tuple{T,R,R}, Tuple{T,R,R,R}, Tuple{T,R,R,R,Bool}, Tuple{T,R,R,R,Bool,String}} where R&lt;:Real where T&lt;:Union{AbstractFeature, AbstractGeometry}" href="#Turf.transform_translate-Union{Tuple{R}, Tuple{T}, Tuple{T,R,R}, Tuple{T,R,R,R}, Tuple{T,R,R,R,Bool}, Tuple{T,R,R,R,Bool,String}} where R&lt;:Real where T&lt;:Union{AbstractFeature, AbstractGeometry}"><code>Turf.transform_translate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">transform_translate([geojson::T[, distance::R[, direction::R]]], vertical::R=0, mutate::Bool=false, units::String=&quot;kilometers&quot;) where {T &lt;: Union{AbstractFeature, AbstractGeometry}, R &lt;: Real}</code></pre><p>Moves any geojson Feature or Geometry of a specified distance along a Rhumb Line on the provided direction angle.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; poly = Polygon([[[0, 29], [3.5, 29], [2.5, 32], [0, 29]]])
Polygon(Array{Array{Float64,1},1}[[[0.0, 29.0], [3.5, 29.0], [2.5, 32.0], [0.0, 29.0]]])

julia&gt; transform_translate(poly, 300, 70)
Polygon(Array{Array{Float64,1},1}[[[2.91184, 29.9228], [6.41184, 29.9228], [5.50479, 32.9228], [2.91184, 29.9228]]])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Transformations.jl#L74-L88">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Turf.intersection-Union{Tuple{T}, Tuple{Point,Point,Any,Array{T,1}}} where T&lt;:Real" href="#Turf.intersection-Union{Tuple{T}, Tuple{Point,Point,Any,Array{T,1}}} where T&lt;:Real"><code>Turf.intersection</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Intersect a segment against one of the 4 lines that make up the bbox</p></div></div><a class="source-link" target="_blank" href="https://github.com/philoez98/Turf.jl/blob/f5804899966300c4f3af640472e45a3642d2a57e/src/lib/Transformations.jl#L488-L490">source</a></section><footer><hr/><a class="previous" href="../examples/"><span class="direction">Previous</span><span class="title">Examples</span></a></footer></article></body></html>
